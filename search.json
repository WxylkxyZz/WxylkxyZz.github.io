[{"title":"Asyncio","url":"/2023/12/30/Asyncio/","content":"协程学习术语解释\ncoroutine – 协程协程是子例程的更一般形式。 子例程可以在某一点进入并在另一点退出。 协程则可以在许多不同的点上进入、退出和恢复。 它们可通过 async def 语句来实现。\n\n\n\n\ncoroutine function – 协程函数返回一个 coroutine 对象的函数。协程函数可通过 async def 语句来定义，并可能包含 await、``async for 和 async with 关键字。\n\n协程通过 async/await 语法来声明协程是编写 asyncio 应用的推荐方式。如下:async def func():    print('hello')    await asyncio.sleep(3)    print('world') # func() -&gt; 直接调用协程不会使其被调度执行asyncio.run(func())要实际运行一个协程，asyncio 提供了以下几种机制:1. asyncio.run() 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)2. 等待一个协程， 如下：import asyncioimport time async def say_after(delay, what):    await asyncio.sleep(delay)    print(what) async def main():    print(f\"started at {time.strftime('%X')}\")     await say_after(1, 'hello')    await say_after(2, 'world')     print(f\"finished at {time.strftime('%X')}\") asyncio.run(main()) # -&gt; print -&gt; 执行了3sstarted at 17:13:52helloworldfinished at 17:13:553. asyncio.create_task()函数用来并发运行 作为 asyncio 任务的 多个协程。 如下：async def main():    task1 = asyncio.create_task(        say_after(1, 'hello'))     task2 = asyncio.create_task(        say_after(2, 'world'))     print(f\"started at {time.strftime('%X')}\")     # Wait until both tasks are completed (should take    # around 2 seconds.)    await task1    await task2     print(f\"finished at {time.strftime('%X')}\") # -&gt; print -&gt; 执行了2sstarted at 17:14:32helloworldfinished at 17:14:344. asyncio.TaskGroup 类提供了 create_task() 的更现代化的替代。 使用此 API，之前的例子将变为:async def main():    async with asyncio.TaskGroup() as tg:        task1 = tg.create_task(say_after(1, 'hello'))        task2 = tg.create_task(say_after(2, 'world'))        print(f\"started at {time.strftime('%X')}\")    print(f\"finished at {time.strftime('%X')}\")asyncio.run(main())### 可等待对象如果一个对象可以在 await 语句中使用，那么它就是 可等待 对象。许多 asyncio API 都被设计为接受可等待对象。可等待 对象有三种主要类型: 协程、任务 和 Future.#### 协程Python 协程属于 可等待 对象，因此可以在其他协程中被等待:async def nested():    return 42 async def main():    # 此时只调用 'nested()' 什么也不会发生。    # 状态是 协程对象已创建但未等待，    # 所以根本不会运行*。    nested()    print(await nested())  # will print \"42\". asyncio.run(main())PS:在本文档中 “协程” 可用来表示两个紧密关联的概念:1. 协程函数: 定义形式为 async def 的函数;2. 协程对象: 调用 协程函数 所返回的对象。任务任务 被用来 ‘并行的’ 调度协程当一个协程通过 asyncio.create_task() 等函数被封装为一个 任务，该协程会被自动调度执行:\nimport asyncio async def nested():    return 42 async def main():    task = asyncio.create_task(nested())    await task asyncio.run(main())\nFutures没明白 摘取自官方文档\n\nFuture 是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果 。当一个 Future 对象 __被等待__，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。通常情况下 没有必要 在应用层级的代码中创建 Future 对象。Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:\n\nasync def main():    await function_that_returns_a_future_object()     # this is also valid:    await asyncio.gather(        function_that_returns_a_future_object(),        some_python_coroutine()    )\n一个很好的返回对象的低层级函数的示例是 loop.run_in_executor()。\n创建任务asyncio.TaskGroup.create_task(coro, *, name=None, context=None)将 coro 协程 封装为一个 Task 并调度其执行。返回 Task 对象。\nname 不为 None，它将使用 Task.set_name() 来设为任务的名称。\n可选的 context 参数允许指定自定义的 contextvars.Context 供 coro 运行。 当未提供 context 时将创建当前上下文的副本。\n该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。\n","categories":["Python"],"tags":["Asyncio"]},{"title":"BeautifulSoup","url":"/2023/12/30/BeautifulSoup/","content":"BeautifulSoup学习简单的直接看网上教程即可 \n知乎\n创建BeautifulSoup对象&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Pyhton教程(www.sanmanong.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p class=\"title\" name=\"sanmanong\"&gt;我的第一个段落。&lt;/p&gt;&lt;a href=\"http://www.sanmanong.com\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;Python教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\n以上述网页为例\n# 导库from bs4 import BeautifulSoup # 创建对象soup = BeautifulSoup(html,'html.parser') # 使用prettify()方法可以可以把要解析的字符串以标准的缩进格式输出。打印一下soup对象的内容，格式化输出：print(soup.prettify())\n四种对象\nTag \n\n即标签\n两种属性 \nname : 得到标签的名字\nattrs: 得到标签的所有属性,类型是一个字典。 soup.p['class']=\"newClass\" del soup.p['class']\n\n\n\n\nNavigableString\n\n使用.string即可获取标签内部的文字\n\n\nBeautifulSoup\n\nBeautifulSoup对象表示的是一个文档的全部内容。大部分时候,可以把它当作 Tag对象，是一个特殊的Tag，同样可以获取它的类型，名称。\n\n\nComment\n\nComment对象是一个特殊类型的NavigableString对象。\n\n\n\n遍历文档树HTML基本格式:&lt;&gt;…构成了所属关系，形成了标签的树形结构\n\n标签树的上行遍历.parent : 节点的父亲标签.parents : 节点先辈标签的迭代类型，用于循环遍历先辈节点\n\n标签树的下行遍历：.contents : 子节点的列表，将所有儿子节点存入列表.children : 子节点的 __迭代类型__，与.contents类似，用于循环遍历儿子节点.descendants : 子孙节点的 __迭代类型__，包含所有子孙节点，用于循环遍历\n\n标签树的平行遍历.next_sibling : 返回按照HTML文本顺序的下一个平行节点标签.previous_sibling : 返回按照HTML文本顺序的上一个平行节点标签.next_siblings : 迭代类型 ，返回按照HTML文本顺序的后续所有平行节点标签.previous_siblings : __迭代类型__，返回按照HTML文本顺序的前续所有平行节点标签\n\n\n下面以下述html为例\nhtml = \"\"\"&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Python教程(www.sanmanong.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p class=\"title\" name=\"sanmanong\"&gt;Python教程学习网站&lt;a href=\"http://www.sanmanong.com\" id=\"link1\"&gt;三码农&lt;/a&gt;&lt;a href=\"https://www.runoob.com/\" id=\"link2\"&gt;三码农&lt;/a&gt;&lt;a href=\"https://www.w3school.com.cn/\" id=\"link3\"&gt;三码农&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\"\"\n将上面内容标准化后 如下\n&lt;html&gt; &lt;head&gt;  &lt;meta charset=\"utf-8\"/&gt;  &lt;title&gt;   Python教程(www.sanmanong.com)  &lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;h1&gt;   我的第一个标题  &lt;/h1&gt;  &lt;p class=\"title\" name=\"sanmanong\"&gt;   Python教程学习网站   &lt;a href=\"http://www.sanmanong.com\" id=\"link1\"&gt;    三码农   &lt;/a&gt;   &lt;a href=\"https://www.runoob.com/\" id=\"link2\"&gt;    三码农   &lt;/a&gt;   &lt;a href=\"https://www.w3school.com.cn/\" id=\"link3\"&gt;    三码农   &lt;/a&gt;  &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;\n上行遍历\nparent节点的父亲标签\n\nprint(soup.p.parent.name)# body\n\nparents通过元素的parents属性可以递归得到元素的所有父辈节点。content = soup.head.title.stringfor parent in content.parents:    print(parent.name) # content所有父节点依次是title、head、html 当然soup也算是个特殊的tag对象所以才有了[document]titleheadhtml[document]\n\n下行遍历\ncontents\n\n子节点列表 切记 是只有子节点\nprint(soup.head.contents) # -&gt; list类型 [&lt;meta charset=\"utf-8\"/&gt;, &lt;title&gt;Python教程(www.sanmanong.com)&lt;/title&gt;]\n\nchildren\nprint(soup.head.children)  # -&gt; list_iterator 列表生成器 &lt;list_iterator object at 0x0000013A6FBC5C88&gt; # 遍历获取所有子节点for i in soup.head.children:    print(i) &lt;meta charset=\"utf-8\"/&gt;&lt;title&gt;Python教程(www.sanmanong.com)&lt;/title&gt; # 这里注意-&gt; body标签的子节点只有title和p, a标签的输出是作为p标签内容的一个整体for i in soup.body.children:      print(i) 输出结果：&lt;h1&gt;我的第一个标题&lt;/h1&gt;  &lt;p class=\"title\" name=\"sanmanong\"&gt;Python教程学习网站&lt;a href=\"http://www.sanmanong.com\" id=\"link1\"&gt;三码农&lt;/a&gt;&lt;a href=\"https://www.runoob.com/\" id=\"link2\"&gt;三码农&lt;/a&gt;&lt;a href=\"https://www.w3school.com.cn/\" id=\"link3\"&gt;三码农&lt;/a&gt;&lt;/p&gt;\n\ndescendantsdescendants属性可以对所有tag的子孙节点进行递归循环\nfor i in soup.body.descendants:    print(i)\n\n平行遍历\n兄弟节点\n\n也就是同级别的节点，且存在于一个父标签下\n\nnext_sibling\n获取当前节点的下一个兄弟节点\n\n\nprevious_sibling\n获取当前节点的上一个兄弟节点，如果节点不存在，则返回 None。\n\n\n\n\nPS：实际文档中的tag的next_sibling和previous_sibling属性通常是字符串或空白，因为空白或者换行也可以被视作一个节点，所以得到的结果可能是空白或者换行。\n\n这里可以看看Xpath学习中的节点类型 \n\n在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点\n\n# repr()函数将值转化为供解释器读取的字符串形式，能将换行以“\\n”形式输出print(repr(soup.p.next_sibling))输出结果：'\\n' print(repr(soup.p.previous_sibling)) 输出结果：'\\n'\n如果将p标签前面的换行去掉，紧跟h1标签，运行结果如下。\nprint(repr(soup.p.previous_sibling)) 输出结果：&lt;h1&gt;我的第一个标题&lt;/h1&gt;\nPS: 其实一般情况下用不到, 但我昨天还真就遇到了一个特殊情况 如下：\nfrom bs4 import BeautifulSoup html = \"\"\"&lt;div&gt;    &lt;span&gt;&lt;/span&gt;    \"内容\"    &lt;a&gt;&lt;/a&gt;&lt;/div&gt;\"\"\" soup = BeautifulSoup(html, 'html.parser') # 获取第一个&lt;span&gt;节点之后的文本内容text_after_first_span = soup.find('span').find_next(text=True) # 获取第一个&lt;span&gt;节点和&lt;a&gt;节点之间的文本内容text_between_span_and_a = soup.find('span').find_next('a').previous_sibling.strip() print(\"第一个&lt;span&gt;节点之后的文本内容:\", text_after_first_span.strip())print(\"第一个&lt;span&gt;节点和&lt;a&gt;节点之间的文本内容:\", text_between_span_and_a)\n\n全部兄弟节点\n\n通过next_siblings和previous_siblings属性可以对当前节点的兄弟节点迭代输出。\n# 以第一个标签a为当前起点，向下查找for sibling in soup.a.next_siblings:      print(repr(sibling)) #    \\n'&lt;a href=\"https://www.runoob.com/\" id=\"link2\"&gt;三码农&lt;/a&gt;'\\n'&lt;a href=\"https://www.w3school.com.cn/\" id=\"link3\"&gt;三码农&lt;/a&gt;'\\n' # 以第一个标签a为当前起点，向上查找for sibling in soup.a.previous_siblings:    print(repr(sibling)) 输出结果：'Python教程学习网站\\n'\n此时你一定会迷惑, 不是寻找兄弟节点吗？ 怎么把p标签内容拿来了？ 我开始学也有疑惑, 这也就是为什么要知道节点类型！\n因为文本也是节点类型！\n搜索文档树find_all()find_all() 方法是 BeautifulSoup 库中用于查找所有匹配标签的方法。该方法用于搜索文档树，返回所有符合条件的元素，结果以列表形式返回。\n方法签名：find_all(name, attrs, recursive, string, limit, **kwargs)\n参数说明：\nname（标签名）：\n\n可以是字符串，正则表达式，方法，列表或 True。\n如果传递字符串，查找所有匹配该标签名的元素。\n如果传递正则表达式，查找所有匹配该正则的元素。\n如果传递方法，该方法将被用于过滤元素。\n如果传递 True，返回所有标签。\n\n\nattrs（属性）：\n\n可以是字典，包含标签的属性和值。\n如果传递字典，查找所有匹配该属性值的元素。\n\n\nrecursive（递归）：\n\n布尔值，默认为 True。\n如果为 True，find_all() 将递归查找所有子孙节点。\n如果为 False，只查找直接子节点。\n\n\nstring（字符串）：\n\n可以是字符串，正则表达式，方法，列表或 True。\n如果传递字符串，查找所有匹配该字符串内容的元素。\n如果传递正则表达式，查找所有匹配该正则的元素。\n如果传递方法，该方法将被用于过滤元素。\n如果传递 True，返回所有包含字符串的元素。\n\n\nlimit（限制数量）：\n\n数字，用于限制返回结果的数量。\n\n\nkwargs：\n\n关键字参数，用于过滤元素的其他属性。\n\n\n\n使用示例：from bs4 import BeautifulSoup html = \"\"\"&lt;html&gt;&lt;head&gt;    &lt;title&gt;Beautiful Soup Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=\"container\"&gt;        &lt;h1&gt;Example Page&lt;/h1&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=\"https://example.com\"&gt;Link 1&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"https://example.com\"&gt;Link 2&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"https://example.com\"&gt;Link 3&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;        &lt;p class=\"description\"&gt;This is an example page.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\"\"\" soup = BeautifulSoup(html, 'html.parser') # 查找所有 a 标签links = soup.find_all('a')for link in links:    print(link.get('href')) # 查找所有包含字符串 \"Link\" 的 li 标签link_li = soup.find_all('li', string='Link')for li in link_li:    print(li.text) # 查找所有包含 \"description\" 类的 p 标签desc_p = soup.find_all('p', class_='description')for p in desc_p:    print(p.text)\n这是一个简单的示例，说明了如何使用 find_all() 方法。你可以根据实际需求灵活使用参数，以获取所需的元素列表。\nfind()二者用法基本相同, 只不过后者返回的是单个元素 ，也就是第一个匹配的元素（类型依然是Tag类型），而前者返回的是所有匹配的元素组成的列表。\n其他函数\n另外，还有许多查询方法，其用法与前面介绍的find_all()、find()方法完全相同， 只不过查询范围不同，这里简单说明一下 。\n\n\nfind_parents()和find_parent()\n\nfind_parents()返回所有祖先节点，find_parent()返回直接父节点。\n\n\nfind_next_siblings()和find_next_sibling()\n\nfind_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。\n\n\nfind_previous_siblings()和find_previous_sibling()\n\nfind_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。\n\n\nfind_all_next()和find_next()\n\nfind_all_next()返回节点后所有符合条件的节点, find_next()返回节点后第一个符合条件的节点。\n\n\nfind_all_previous()和find_previous()\n\nfind_all_previous()返回节点前所有符合条件的节点, find_previous()返回节点前第一个符合条件的节点。\n\n\n\nCSS选择器介绍CSS（层叠样式表）选择器是一种用于选择 HTML 元素的模式。它允许你根据元素的标签名、类、ID、属性等条件来选择和样式化页面中的元素。以下是一些常用的 CSS 选择器：\n\n元素选择器：\n\nelement: 选择所有具有指定标签名的元素。p {  color: blue;}\n\n\n类选择器：\n\n.class: 选择所有具有指定类名的元素。.highlight {  background-color: yellow;}\n\n\nID 选择器：\n\n#id: 选择具有指定 ID 的元素。#header {  font-size: 18px;}\n\n\n后代选择器：\n\nancestor descendant: 选择 ancestor 内的所有 descendant 元素。article p {  font-style: italic;}\n\n\n子元素选择器：\n\nparent &gt; child: 选择 parent 元素下的所有直接子元素 child。nav &gt; ul {  list-style-type: none;}\n\n\n通用选择器：\n\n*: 选择所有元素。* {  margin: 0;  padding: 0;}\n\n\n属性选择器：\n\n[attribute]: 选择具有指定属性的元素。\ninput[type=\"text\"] {  border: 1px solid #ccc;}\n\n[attribute=value]: 选择具有指定属性和值的元素。\na[href=\"https://www.example.com\"] {  color: red;}\n\n\n伪类选择器：\n\n:hover: 选择鼠标悬停在元素上的状态。\na:hover {  text-decoration: underline;}\n\n:nth-child(n): 选择元素的第 n 个子元素。\nli:nth-child(odd) {  background-color: #f2f2f2;}\n\n\n\n这只是 CSS 选择器的一小部分。CSS 选择器允许你根据各种条件来选择元素，以便更精确地定义样式。使用 CSS 选择器可以提高代码的可维护性和灵活性。\n例子Beautiful Soup 提供了对 CSS 选择器的支持，你可以使用 select 方法通过 CSS 选择器来筛选文档中的元素。下面是一些使用 BeautifulSoup 中 CSS 选择器的基本用法：\nfrom bs4 import BeautifulSoup html = \"\"\"&lt;html&gt;  &lt;body&gt;    &lt;div id=\"container\"&gt;      &lt;h1 class=\"title\"&gt;Beautiful Soup&lt;/h1&gt;      &lt;ul class=\"list\"&gt;        &lt;li&gt;Item 1&lt;/li&gt;        &lt;li&gt;Item 2&lt;/li&gt;        &lt;li&gt;Item 3&lt;/li&gt;      &lt;/ul&gt;      &lt;p class=\"paragraph\"&gt;Hello, Beautiful Soup!&lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\"\"\" soup = BeautifulSoup(html, 'html.parser') # 使用 CSS 选择器选择元素title = soup.select('h1.title')  # 选择 class 为 'title' 的 h1 元素print(title[0].text) items = soup.select('ul.list li')  # 选择 class 为 'list' 的 ul 下的所有 li 元素for item in items:    print(item.text) paragraph = soup.select('div#container &gt; p.paragraph')  # 选择 id 为 'container' 的 div 直接子元素中 class 为 'paragraph' 的 p 元素print(paragraph[0].text)\n解释一下这个例子：\n\nh1.title 选择所有 class 为 ‘title’ 的 h1 元素。\nul.list li 选择 class 为 ‘list’ 的 ul 元素下的所有 li 元素。\ndiv#container &gt; p.paragraph 选择 id 为 ‘container’ 的 div 直接子元素中 class 为 ‘paragraph’ 的 p 元素。\n\n在 select 方法中，你可以使用常见的 CSS 选择器语法，包括标签名、类选择器、ID 选择器、子元素选择器等。这使得 Beautiful Soup 在处理 HTML 或 XML 文档时更加灵活。\nPS:还有要说的一点是 层级选择器 中&gt; 表示一个层级 空格代表 多个层级\n伪类选择器CSS 伪类是用于选择文档中不同状态或位置的元素的特殊选择器。以下是一些常见的 CSS 伪类选择器：\n\n:hover：\n\n选择鼠标悬停的元素。\n示例：a:hover { color: red; }\n\n\n:active：\n\n选择用户点击并保持按下的元素。\n示例：button:active { background-color: yellow; }\n\n\n:focus：\n\n选择当前获得焦点的表单元素。\n示例：input:focus { border: 2px solid blue; }\n\n\n:first-child：\n\n选择父元素下的第一个子元素。\n示例：li:first-child { font-weight: bold; }\n\n\n:last-child：\n\n选择父元素下的最后一个子元素。\n示例：li:last-child { color: green; }\n\n\n:nth-child(an+b)：\n\n选择父元素下按照规律排列的子元素，其中 a 和 b 是整数。\n示例：tr:nth-child(2n) { background-color: #f2f2f2; }\n\n\n:nth-of-type(an+b)：\n\n选择父元素下按照规律排列的特定类型的子元素。\n示例：ul li:nth-of-type(odd) { background-color: #f0f0f0; }\n\n\n:not(selector)：\n\n选择不匹配指定选择器的元素。\n示例：input:not([type=\"text\"]) { opacity: 0.5; }\n\n\n:first-of-type：\n\n选择父元素下的特定类型的第一个子元素。\n示例：h2:first-of-type { font-size: 24px; }\n\n\n:last-of-type：\n\n选择父元素下的特定类型的最后一个子元素。\n示例：p:last-of-type { color: red; }\n\n\n\n这些伪类选择器允许开发者根据元素的状态、位置或结构选择不同的元素，使得 CSS 样式更加灵活和适应各种情境。“按照规律排列” 指的是按照一定的数学规律选择元素。在 :nth-child(an+b) 和 :nth-of-type(an+b) 中，a 和 b 是整数，用于定义选择元素的规律。\n\nan 表示周期的长度，每隔 a 个元素会重复一次选择。\nb 表示起始位置，表示从第 b 个元素开始选择。\n\n举例说明：\n\n:nth-child(2n) 选择的是所有位置是偶数的元素。\n:nth-child(3n+1) 选择的是所有位置是 1、4、7、10、… 的元素。\n:nth-of-type(odd) 选择的是所有位置是奇数的某一特定类型的元素。\n\n这样的规律选择使得样式能够更加灵活地应用到特定位置或类型的元素上。\n“按照规律排列” 指的是按照一定的数学规律选择元素。在 :nth-child(an+b) 和 :nth-of-type(an+b) 中，a 和 b 是整数，用于定义选择元素的规律。\n\nan 表示周期的长度，每隔 a 个元素会重复一次选择。\nb 表示起始位置，表示从第 b 个元素开始选择。\n\n举例说明：\n\n:nth-child(2n) 选择的是所有位置是偶数的元素。\n:nth-child(3n+1) 选择的是所有位置是 1、4、7、10、… 的元素。\n:nth-of-type(odd) 选择的是所有位置是奇数的某一特定类型的元素。\n\n这样的规律选择使得样式能够更加灵活地应用到特定位置或类型的元素上。\n记录刚学习的问题:实例化传入html时的问题\n在实例化soup对象时 response可以直接传 本地文件要先读入再传\n\n1. 直接传responsesoup = BeautifulSoup(response,'html.parser') 2. 先读入html再传filename = 'your_html_file.html'with open(filename, 'r', encoding='utf-8') as file:    html_content = file.read()soup = BeautifulSoup(html_content, 'html.parser')\nclass标签class标签内内容有空格隔开\n如果一个 HTML 元素的 class 属性中有空格分隔的多个值，每个空格分隔的值都被视为一个独立的类名。在你提供的例子中，class 属性的值是 “a-size-large product-title-word-break”，这表示该元素具有两个类名： “a-size-large” 和 “product-title-word-break”。\n你可以使用以下方式选择这个具有两个类名的元素：\n.a-size-large {    /* 这里是你的样式规则 */} .product-title-word-break {    /* 这里是你的样式规则 */}\n或者，你也可以选择同时具有这两个类的元素：\n.a-size-large.product-title-word-break {    /* 这里是你的样式规则 */}\n这个选择器会匹配同时具有 “a-size-large” 和 “product-title-word-break” 两个类的元素。\n三种获取文本内容的区别在 BeautifulSoup 中，text、string 和 get_text() 都用于获取标签内的文本内容，但它们有一些微小的差异。\n\ntext 属性：\n\ntag.text 返回标签内的文本内容。\n如果标签包含嵌套标签，text 将递归获取所有嵌套标签内的文本，并将它们连接起来。\n如果标签内有注释，text 也会获取注释内容。\n\nfrom bs4 import BeautifulSoup html = \"&lt;p&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt;\"soup = BeautifulSoup(html, 'html.parser')p_tag = soup.find('p') print(p_tag.text)# 输出: This is bold text.\n\nstring 属性：\n\ntag.string 用于获取标签内的文本内容。\n如果标签包含嵌套标签，string 只会获取第一个直接子元素的文本，而不会递归获取所有嵌套标签的文本。\n如果标签内有注释，string 不会获取注释内容。\n\nfrom bs4 import BeautifulSoup html = \"&lt;p&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt;\"soup = BeautifulSoup(html, 'html.parser')p_tag = soup.find('p') print(p_tag.string)# 输出: This is\n\nget_text() 方法：\n\ntag.get_text() 返回标签内的文本内容。\n与 text 类似，get_text() 会递归获取所有嵌套标签内的文本，包括注释。\n可以传递参数来定制分隔符。\n\nfrom bs4 import BeautifulSoup html = \"&lt;p&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt;\"soup = BeautifulSoup(html, 'html.parser')p_tag = soup.find('p') print(p_tag.get_text())# 输出: This is bold text.\n\n总体而言，这三个方法在大多数情况下都可以互相替代，选择使用哪个主要取决于你对文本内容的需求以及是否希望递归获取所有嵌套标签的文本。\nselect跟select_one区别select_one 和 select 是 BeautifulSoup 提供的两种方法，用于在 HTML 或 XML 文档中选择元素。它们之间的主要区别在于返回的结果集的不同：\n\nselect 方法：\n\n返回一个 ResultSet 对象，这是一个包含所有匹配元素的列表。\n如果没有匹配的元素，返回空列表 []。\n适用于选择器表达式匹配多个元素的情况。\n\n示例：\nelements = soup.select('div.my-class')  # 返回一个包含所有匹配元素的列表\n\nselect_one 方法：\n\n返回找到的第一个匹配元素，而不是 ResultSet。\n如果没有找到匹配的元素，返回 None。\n适用于只关心第一个匹配元素的情况。\n\n示例：\nelement = soup.select_one('div.my-class')  # 返回找到的第一个匹配元素\n\n使用 select_one 的主要优势在于，如果你确定只需要获取第一个匹配的元素，可以避免获取整个 ResultSet 对象，提高代码的效率。但如果你关心多个匹配的元素，应该使用 select 方法。\n总体而言，选择使用哪个方法取决于你的需求。如果你只需要获取一个元素，可以使用 select_one；如果你需要多个元素，可以使用 select。\n","categories":["Python"],"tags":["BeautifulSoup"]},{"title":"Encrypt and Decode","url":"/2023/04/27/Encrypt-and-Decode/","content":"1. Base64加密/解密Base64是一种常用的编码方式，通常用于将二进制数据转换为文本格式，从而可以在网络上或其他不支持二进制传输的环境中传输数据。Base64编码方法涉及到将原始二进制数据分割成固定的小块，每个小块都以6bit的形式表示为一个字符，最终组成一个文本字符串。\npython的base64库提供了Base64编码/解码的功能，可以直接使用如下代码进行编码和解码操作：\nimport base64# 编码data = b'hello world'encoded_data = base64.b64encode(data)print(encoded_data)# 解码decoded_data = base64.b64decode(encoded_data)print(decoded_data)\n\n2. MD5加密MD5是一种哈希算法，可以将任意长度的数据转换为固定长度的hash值，通常用于密码加密、数字签名等方面。MD5算法是单向的不可逆的，因此不会出现密码泄露的情况。\npython的hashlib库中提供了MD5算法的实现，可以直接使用如下代码进行加密操作：\nimport hashlib# 加密data = b'hello world'md5 = hashlib.md5()md5.update(data)encrypted_data = md5.hexdigest()print(encrypted_data)\n\n3. SHA1加密SHA1是一种安全哈希算法，类似于MD5，可以将任意长度的数据转换为固定长度的hash值。在密码学安全性方面，SHA1比MD5更为可靠，但在哈希效率、碰撞检测等方面略逊一筹。\n使用python的hashlib库中的SHA1算法，可以类似于MD5一样进行加密操作，如下所示：\nimport hashlib#加密data = b'hello world'sha1 = hashlib.sha1()sha1.update(data)encrypted_data = sha1.hexdigest()print(encrypted_data)\n\n4. AES加密AES是一种高级加密标准，也是目前应用广泛的加密算法之一。与前面三种算法不同，AES算法是一种对称加密算法，需要使用相同的密钥进行加密和解密操作。AES算法支持多种密钥长度和加密模式，可以根据实际需求进行调整。\npython的pycryptodome库提供了AES算法的实现，可以使用如下代码进行加密和解密操作：\nfrom Crypto.Cipher import AESimport base64# 加密data = b'hello world'key = b'this is a secret key'mode = AES.MODE_CBCiv = b'1234567890123456'encryptor = AES.new(key, mode, iv)encrypted_data = encryptor.encrypt(data)encoded_data = base64.b64encode(encrypted_data)print(encoded_data)# 解密decoded_data = base64.b64decode(encoded_data)decryptor = AES.new(key, mode, iv)decrypted_data = decryptor.decrypt(decoded_data)print(decrypted_data)\n\n5. RSA加密RSA加密算法是一种非对称加密算法，它需要两个密钥，分别为公钥和私钥。公钥可以公开，用于加密数据；私钥保密，用于解密数据。RSA算法不仅可以用于加密解密，还可以用于数字签名、身份认证等。\n使用python的Crypto库中的RSA算法，可以生成密钥对、进行加密和解密操作，如下所示：\nfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5import base64# 生成RSA密钥对key = RSA.generate(1024)private_key = key.export_key()public_key = key.publickey().export_key()# 公钥加密，私钥解密data = b'hello world'rsakey = RSA.import_key(private_key)cipher = PKCS1_v1_5.new(rsakey)encrypted_data = base64.b64encode(cipher.encrypt(data))print(encrypted_data)rsakey = RSA.import_key(public_key)cipher = PKCS1_v1_5.new(rsakey)decrypted_data = cipher.decrypt(base64.b64decode(encrypted_data), None)print(decrypted_data)\n\n以上就是五种常用的加密算法的基本实现，您可以根据实际需求结合UI开发进行集成。对于UI设计，您可以使用Tkinter模块、PyQt等开源工具。\n","categories":["心血来潮"],"tags":["Python","加密解密"]},{"title":"Hello World","url":"/2022/07/14/Hello-World/","content":"记录Keep主题使用中积累的问题\n \n\n\n文章置顶实现文章置顶，需要在文章 .md 文件中添加 sticky 属性，sticky 值越大，在主页中置顶的文章越靠前。\n文章截取实现对文章自由截取，并在首页完整显示出来  \n&lt;!-- more --&gt; 加入文章即可\n关闭文章版权信息copyright_info参数 默认true 只有设置为false时生效\n关闭文章TOC目录结构toc参数 默认true 只有设置为false时生效\n关闭文章评论comment参数 默认true 只有设置为false时生效\n配置文章时效提示\naging 表示是否开启该文章的时效提示\naging_days 设置时效提示的天数\n\n数学公式mathjax参数, 设置为true生效例如:\n测试集成GitHub Actions测试 成功不成功！！！！！！！！！！！！！！！！！！！！！！  \ngit add -Agit commit -m “Create”git push -u origin mastergit add -Agit commit -m “Updata”git pull测试删除.\n测试代码print(\"测试代码\")async def fun()    await asyncio.sleep(10)\n\n未完待续……","categories":["随笔"],"tags":["主题"]},{"title":"Learn Python","url":"/2023/12/30/Learn-Python/","content":"Python-100-days基础常见内置函数、方法\n\n\ntype()：检测变量类型\nint()：将一个数值或字符串转换成整数，可以指定进制。\nfloat()：将一个字符串转换成浮点数\nstr()：将指定的对象转换成字符串形式，可以指定编码\nchr()：将整数转换成该编码对应的字符串（一个字符）\nord()：将字符串（一个字符）转换成对应的编码（整数）\nlen()：计算字符串的长度\nisinstance(object, classinfo)：用于检查一个对象是否是指定的类型或类的实例\ndict.items(): 以列表返回可遍历的(键, 值) 元组数组for key,value in dict.items():#当两个参数时 返回的时元组内的k跟vfor i in dict.items():#当参数只有一个时 返回的是元组\nzip(): 用于将多个可迭代对象（例如列表、元组等）中对应的元素打包成元组，然后返回这些元组组成的迭代器。它能够按照最短的输入序列长度进行配对，当其中一个序列到达末尾时，迭代就停止。\n\n取模与取余通常取模运算也叫取余运算，它们返回的结果都是余数。对于整数a，b来说，取模运算或者取余运算的方法要分如下两步进行：\n\n第一步：求整数商c = a/b\n第二步：计算模或者余数r = a - (c * b)\n\n\n取模运算和取余运算唯一的差别在于第一步。取模运算在计算整数商时，采用的是向负无穷大的方向取整。取余运算在计算整数商时，采用的是向0方向取整。  \n\n举个栗子：\na = 4 , b = -3第一步： 4/(-3) = -1.333…3..3(无限循环)对于取模运算，得到的整数商将为-2（向负无穷取整）对于取余运算，得到的整数商将为-1（向0取整）取模结果为 c = -2取余结果为 c = -1第二步：对于取模运算，r = 4 - ((-2) * (-3)) = 2对于取余运算，r = 4 - ((-1) * (-3)) = 1故，取模结果为2，取余结果为1。  \n总结\n\n如果a，b符号相同，得到的整数商必然大于0，因此取模运算和取余运算取整的方向相同，因此得到的结果相同。\n如果a，b符号不同，得到的整数商必然小于0,取模运算向负无穷方向取整，取余运算向0方向取整，两个方向不同，得到的结果必然不同。并且取模运算得到的结果的符号与b的符号相同，取余运算的结果的符号与a的结果相同。\n\n函数的参数我们给下面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的\nfrom random import randint  def roll_dice(n=2):    \"\"\"摇色子\"\"\"    total = 0    for _ in range(n):        total += randint(1, 6)    return total  def add(a=0, b=0, c=0):    \"\"\"三个数相加\"\"\"    return a + b + c  # 如果没有指定参数那么使用默认值摇两颗色子print(roll_dice())# 摇三颗色子print(roll_dice(3))print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))# 传递参数时可以不按照设定的顺序进行传递print(add(c=50, a=100, b=200))\n其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。\n# 在参数名前面的*表示args是一个可变参数def add(*args):    total = 0    for val in args:        total += val    return total  # 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))\n字符串跟常见数据结构字符串\nPython为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符（切片运算）\n\n代码如下所示。  \ns1 = 'hello ' * 3print(s1) # hello hello hello s2 = 'world's1 += s2print(s1) # hello hello hello worldprint('ll' in s1) # Trueprint('good' in s1) # Falsestr2 = 'abc123456'# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45\n注意 \n\nprint(str2[::-1]) # 654321cba str2[::-1] 使用了 Python 中的切片（slice）操作来实现字符串的倒序输出。\n 解释： str2 是一个字符串。 [::] 是切片语法，它用于从一个序列（如字符串）中获取子序列。 第一个空位 :: 表示从头到尾，即包含了整个字符串。 最后一个数字 1 是步长（stride），它表示 从左到右 每次取一个字符。 当我们将步长设为 -1 时，就会 从右到左 每次取一个字符，因此，str2[::-1] 就实现了将字符串倒序输出的效果。\n 举个例子，假如 str2 的值是 “Hello”，那么 str2[::-1] 就会返回 “olleH”，因为它是将 “Hello” 从右到左每次取一个字符。\n 列表切片亦是如此\n\n索引是左开右闭的\n\n\n在Python中，我们还可以通过一系列的方法来完成对字符串的处理，代码如下所示。\nstr1 = 'hello, world!'# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find('or')) # 8print(str1.find('shit')) # -1# 与find类似但找不到子串时会引发异常# print(str1.index('or'))# print(str1.index('shit'))# 检查字符串是否以指定的字符串开头print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith('!')) # True# 将字符串以指定的宽度居中 在两侧填充指定的字符print(str1.center(50, '*'))# 将字符串以指定的宽度靠右放置 在左侧填充指定的字符print(str1.rjust(50, ' '))# 将字符串以指定的宽度靠左放置 在右侧填充指定的字符print(str1.ljust(50, ' '))str2 = 'abc123456'# 检查字符串是否由数字构成print(str2.isdigit())  # False# 检查字符串是否以字母构成print(str2.isalpha())  # False# 检查字符串是否以数字和字母构成print(str2.isalnum())  # Truestr3 = '  jackfrued@126.com 'print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) # rfind()它用于在字符串中从右边开始查找指定子字符串，并返回子字符串的最后一次出现的位置（索引）。 \nf-string（格式化字符串字面量）用法如下\nname = \"Charlie\"age = 35print(f\"My name is {name} and I am {age} years old.\")\n\n在 f-string 中，你可以使用类似于传统的字符串格式化方法来格式化数字。你可以在 f-string 中使用 :{format_spec} 语法，其中 format_spec 是一个格式规范字符串，用于指定如何格式化数字\n\na = 3.1415b = -3.1415print(f'保留两位小数-&gt; {a:.2f}')print(f'保留两位小数-&gt; {b:.2f}')# 这里说明数的正负跟下面的例子中的+-没关系# + 表示显示正负号，无论数字是正数还是负数，都会显示符号 就是不论正负数都带符号 因为正数可以显示不带+号 +1 = 1print('-'*100) print(f'保留两位小数-&gt; {a:+.2f}')print(f'保留两位小数-&gt; {b:+.2f}')print('-'*100) # - 表示对数字进行左对齐 （默认是右对齐）print(f'保留两位小数-&gt; {a:-.2f}')print(f'保留两位小数-&gt; {b:-.2f}')print('-'*100) # 不保留小数print(f'不保留小数-&gt; {a:.0f}')print(f'不保留小数-&gt; {b:.0f}')print('-'*100) # ^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。# 也就是说箭头指哪 本体在哪！c = 5print(f'填充字符{c:*&lt;8d}')print(f'填充字符{c:*&gt;8d}')print('-'*100) print(f'默认右对齐{c:&gt;10d}')print(f'改为左对齐{c:&lt;10d}')print(f'改居中对齐{c:^10d}')print('-'*100) # 逗号分隔的数字格式d = 1000000000print(f'逗号分隔模式 {d:,d}')print('-'*100) # 百分比格式e = 0.48print(f'百分数 {e:.2%}')print('-'*100)# 指数数字格式print(f'指数数字格式 {d:.1e}')print(f'指数数字格式 {d:.3e}')print('-'*100) # 进制转换r = 18print(f'十进制:-&gt; {r:d}')print(f'二进制:-&gt; {r:b}')print(f'八进制:-&gt; {r:o}')print(f'16进制:-&gt; {r:x}')# 加上前缀 -&gt; 0x 是一个用来标识后面的数字是十六进制的前缀。print(f'16进制:-&gt; {r:#x}')print(f'16进制:-&gt; {r:#X}')print('-'*100) \n列表\nenumerate函数\n\n\nenumerate() 是 Python 中的一个内置函数，用于将一个可遍历的数据对象（如列表、元组、字符串等）组合为一个索引序列，__同时返回元素和索引__。它的基本语法是：enumerate(iterable, start=0)其中：iterable 是可遍历的数据对象，如列表、元组、字符串等。start 是可选参数，表示起始的索引值，默认为0。enumerate() 返回一个可迭代的对象，每个元素是一个包含索引和对应元素的元组。\n\nlist1 = [1, 3, 5, 7, 100]# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1):    print(index, elem)\n\n如何向列表中添加元素以及如何从列表中移除元素。\nlist1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400) # 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9 # 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1:    list1.remove(3)if 1234 in list1:    list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000] # 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000] # 清空列表元素list1.clear()print(list1) # []\n\n列表排序操作\n\n\nlist1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']list2 = sorted(list1)# sorted函数返回列表排序后的拷贝 并不会修改传入的列表！# 函数的设计就应该像sorted函数一样尽可能不产生副作用list3 = sorted(list1, reverse=True)# 通过key关键字参数指定 根据字符串长度进行排序 而不是默认的字母表顺序list4 = sorted(list1, key=len)print(list1)print(list2)print(list3)print(list4)# 给列表对象发出排序消息 直接在列表对象上进行排序list1.sort(reverse=True)print(list1)\n列表生成式和 生成器f = [x for x in range(1, 10)]print(f)f = [x + y for x in 'ABCDE' for y in '1234567']print(f)# 用列表的生成表达式语法创建列表容器# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间f = [x ** 2 for x in range(1, 1000)]print(sys.getsizeof(f))  # 查看对象占用内存的字节数print(f) # 请注意下面的代码创建的不是一个列表而是一个 生成器对象# 通过生成器可以获取到数据但它不占用额外的空间存储数据# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)f = (x ** 2 for x in range(1, 1000))print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间print(f) # &lt;generator object &lt;genexpr&gt; at 0x000002637460FED0&gt; 生成了一个对象for val in f:    print(val)\n注意 : \n[x for x in range(1, 11) if x % 2 == 0] -&gt; [2, 4, 6, 8, 10]\n[x if x % 2 == 0 for x in range(1, 11)] -&gt; SyntaxError: invalid syntax\n第一句之所以可以成功输出 是因为跟在for后面的if是一个筛选条件，不能带else，不然如何筛选啊？🤬如果你把if写在for前， 那必然会报错， 因为写在前面就是个表达式了！必须带else,它必须根据x计算出一个结果。\n可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。\n还有一点:两次for大的在前面奥eg:values = [cell.value for row in scope for cell in row]\n还有+\n在切片的表示中，[start:stop] 表示从索引 start 开始，一直到索引 stop 之前的位置,也就是左闭右开.还有切片是从左往右切 所以如果负数的话这样写 [-2, -1]还有一点在切片中，如果不指定 stop ，则默认会一直取到列表的末尾（这里注意是结尾 包含了最后一个值）\n元组元组跟列表的不同之处是 元组的元素不能修改\n# 定义元组t = ('骆昊', 38, True, '四川成都')print(t)# 获取元组中的元素print(t[0])print(t[3])# 遍历元组中的值for member in t:    print(member)# 重新给元组赋值# t[0] = '王大锤'  # TypeError!!!! # 变量t重新引用了新的元组原来的元组将被垃圾回收t = ('王大锤', 20, True, '云南昆明')print(t) # 将元组转换成列表person = list(t)print(person)# 列表是可以修改它的元素的person[0] = '李小龙'person[1] = 25print(person)# 将列表转换成元组fruits_list = ['apple', 'banana', 'orange']fruits_tuple = tuple(fruits_list)print(fruits_tuple)\n\n如果可能，能用tuple代替list就尽量用tuple\n\n坑 \ntuple_1 = (1)print(tuple_1, type(tuple_1)) tuple_2 = (1,)print(tuple_2, type(tuple_2)) # print1 &lt;class 'int'&gt;(1,) &lt;class 'tuple'&gt;\n\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1\n\n集合\nPython中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。\n\n# 1. 创建和使用集合 # 创建集合的字面量语法set1 = {1, 2, 3, 3, 3, 2}print(set1)print('Length =', len(set1))# 创建集合的构造器语法(面向对象部分会进行详细讲解)set2 = set(range(1, 10))set3 = set((1, 2, 3, 3, 2, 1))print(set2, set3)# 创建集合的推导式语法(推导式也可以用于推导集合)set4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0}print(set4) # 2. 向集合添加元素和从集合删除元素。 set1.add(4)set1.add(5)set2.update([11, 12])set2.discard(5)if 4 in set2:    set2.remove(4)print(set1, set2)print(set3.pop())print(set3) # 3. 集合的成员、交集、并集、差集等运算。# 集合的交集、并集、差集、对称差运算print(set1 &amp; set2)# print(set1.intersection(set2))print(set1 | set2)# print(set1.union(set2))print(set1 - set2)# print(set1.difference(set2))print(set1 ^ set2)# print(set1.symmetric_difference(set2))# 判断子集和超集print(set2 &lt;= set1)# print(set2.issubset(set1))print(set3 &lt;= set1)# print(set3.issubset(set1))print(set1 &gt;= set2)# print(set1.issuperset(set2))print(set1 &gt;= set3)# print(set1.issuperset(set3)) \n字典\n字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。\n\n# 创建字典的字面量语法scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82}print(scores)# 创建字典的构造器语法items1 = dict(one=1, two=2, three=3, four=4)# 通过zip函数将两个序列压成字典items2 = dict(zip(['a', 'b', 'c'], '123'))# 创建字典的推导式语法items3 = {num: num ** 2 for num in range(1, 10)}print(items1, items2, items3)# 通过键可以获取字典中对应的值print(scores['骆昊'])print(scores['狄仁杰'])# 对字典中所有键值对进行遍历for key in scores:    print(f'{key}: {scores[key]}')# 更新字典中的元素scores['白元芳'] = 65scores['诸葛王朗'] = 71scores.update(冷面=67, 方启鹤=85)print(scores)if '武则天' in scores:    print(scores['武则天'])print(scores.get('武则天'))# get方法也是通过键获取对应的值但是可以设置默认值print(scores.get('武则天', 60))# 删除字典中的元素print(scores.popitem())# popitem() 会弹出字典中的一个任意键值对（在 Python 3.7+ 中会弹出最后一个插入的键值对），并将该键值对以元组形式返回，然后将该键值对从字典中移除。print(scores.popitem())print(scores.pop('骆昊', 100))# 清空字典scores.clear()print(scores)\n文件读写简单直接看菜鸟教程即可主要就是+ : 打开一个文件进行 更新 (可读可写,比如r是只读,r+时读写咯)a : 追加 注意只有a是追加 w跟r系列文件指针都会放在开头，本来有内容会被覆盖x : 也是写入，但是不一样的是如果文件已经存在会产生异常\n读写JSON文件 一般只用几个\n\ndump : 将Python对象按照JSON格式序列化到文件中\ndumps: 将Python对象处理成JSON格式的字符串\nload : 将文件中的JSON数据反序列化成对象\nloads: 将字符串的内容反序列化成Python对象\n\n\n这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。\n\nrandom模块\n\n\n函数\n描述\n\n\n\nrandom()\n返回范围在 [0.0, 1.0) 之间的随机浮点数。\n\n\nrandint(a, b)\n返回一个整数 N，使得 a &lt;= N &lt;= b。\n\n\nuniform(a, b)\n返回范围在 [a, b) 之间的随机浮点数  区间可以不是整数\n\n\nrandrange(start, stop, step)\n从指定范围内随机选择一个元素。\n\n\nchoice(seq)\n从非空序列中随机选择一个元素。\n\n\nshuffle(seq)\n原地随机打乱序列的元素顺序。\n\n\nsample(population, k)\n从总体中选择 k 个唯一元素，并返回一个列表。\n\n\nseed([x])\n使用给定的种子值初始化随机数生成器。\n\n\n这些函数是 Python 中 random 模块的一部分，通常用于生成随机数或以随机方式操作序列。\nmatch caseage = 15 match age:    case age if age &lt; 10:        print(f'&lt; 10 years old: {age}')    case 10:        print('10 years old')    case 11 | 12 | 13 | 14 | 15 | 16:        print('11~16 years old')    case 17:        print('17 years old')    case _:        print('not sure')\n菜鸟教程能用match case尽量不用if elif else\n面向对象编程定义: 类是对象的蓝图和模板，而对象是类的实例\n定义类class Student:    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age     # 在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。     def study(self, course_name):        print(f'{self.name}正在学习{course_name}')  def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('小明', 38)    # 给对象发study消息    stu1.study('Python程序设计')  if __name__ == '__main__':    main()\n访问权限\n对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。\n\nclass Test:    def __init__(self, foo):        self.__foo = foo     def __bar(self):        print(self.__foo)        print('__bar')  def main():    test = Test('Hello')    test.__bar()    # 这句报错 : AttributeError: 'Test' object has no attribute '__bar'    print(test.__foo)    # 这句报错: AttributeError: 'Test' object has no attribute '__foo'  if __name__ == '__main__':    main() \n\n但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是”We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻\n\nclass Test:    def __init__(self, foo):        self.__foo = foo     def __bar(self):        print(self.__foo)        print('__bar')  def main():    test = Test('hello')    test._Test__bar()    print(test._Test__foo)    '''打印结果    hello    __bar    hello    ''' if __name__ == '__main__':    main()\n@property装饰器\n之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。\n\nclass Person:    def __init__(self, name, age):        self._name = name        self._age = age     # 访问器 getter方法    @property    def name(self):        return self._name     @property    def age(self):        return self._age     @age.setter    def age(self, age):        self._age = age     def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)  def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.name = '小明'    print(person.name) # AttributeError: property 'name' of 'Person' object has no setter    person.play()  if __name__ == '__main__':    main()\n以上内容属实没看懂什么意思 以下为理解内容\nproperty 装饰器是Python中用于管理类属性的一种特殊方法。它允许你 将一个方法标记为属性 ，从而可以 像访问普通属性一样访问该方法 。\n通常情况下，我们定义一个类的属性时，会使用类的实例变量来存储数据。然而，有时我们可能需要在获取或者设置属性值时 __执行一些额外的逻辑__，例如进行数据校验或转换。\nproperty 装饰器允许你在访问属性时 自定义其行为。 它 实际上将一个方法“伪装”成一个属性，当你访问这个属性时，实际上会调用相应的方法。\n举例来说:\n假设你有一个类，表示一个人的信息，其中包括了名字和姓氏：\nclass Person:    def __init__(self, first_name, last_name):        self.first_name = first_name        self.last_name = last_name\n现在，你想要获取这个人的全名，你可以使用下面的方法：\nperson = Person('John', 'Doe')full_name = f'{person.first_name} {person.last_name}'\n但是如果你想让获取全名的方式更简单一些，就可以使用property装饰器。它让你可以像访问属性一样获取全名，而不是调用一个方法：\nclass Person:    def __init__(self, first_name, last_name):        self.first_name = first_name        self.last_name = last_name     @property    def full_name(self):        return f'{self.first_name} {self.last_name}'\n现在你可以这样获取全名：\nperson = Person('John', 'Doe')full_name = person.full_name\n这就像在获取一个普通的属性一样，但实际上在后台调用了一个方法。\n另外，如果你想要设置全名，你可以使用@full_name.setter装饰器来定义一个方法，使得你可以直接给full_name赋值：\nclass Person:    def __init__(self, first_name, last_name):        self.first_name = first_name        self.last_name = last_name     @property    def full_name(self):        return f'{self.first_name} {self.last_name}'     @full_name.setter    def full_name(self, value):        first, last = value.split()        self.first_name = first        self.last_name = last\n现在你可以这样设置全名：\nperson = Person('John', 'Doe')person.full_name = 'Jane Doe'\nslots魔法__slots__ 是Python中一个特殊的类属性，它允许你限制一个类实例能拥有的属性。\n通常情况下，Python的类实例可以动态地添加新的属性。这意味着你可以在实例化之后随时为其添加新的属性。例如：\nclass Person:    pass person = Person()person.name = 'John'person.age = 30\n在上面的例子中，我们创建了一个Person类的实例，并随时为其添加了name和age两个属性。\n但是，有时候我们希望限制一个类实例可以拥有的属性，这时就可以使用__slots__。\n以下是一个使用__slots__的例子：\nclass Person:    __slots__ = ('name', 'age')     def __init__(self, name, age):        self.name = name        self.age = age person = Person('John', 30)person.name = 'Jane'  # 可以正常设置属性person.city = 'New York'  # 会抛出 AttributeError，因为'city'不在__slots__中\n在这个例子中，__slots__ 被设置为一个包含了'name'和'age'的元组。这意味着Person类的实例只能拥有这两个属性，任何尝试添加其他属性都会引发AttributeError。\n使用__slots__的好处是可以减少实例的内存消耗，因为Python不再需要为每个实例维护一个字典来存储属性。相反，它直接为属性分配一个固定的槽位，提高了访问速度。\n需要注意的是，__slots__ 只对当前类的实例起作用，不会影响子类。如果子类也定义了__slots__，那么它会覆盖父类的定义。\n综上就是你初始化属性时 如果不想让人再访问某些属性 可以用self.__name定义属性 这样在访问时直接报错没这个属性 (但是也可以用特殊手段访问,比如用_Person__name 在该属性前加上下划线以及类的名称)\n一般情况不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效， 就比如让你定义name你直接person.name = 18 你叫18是吧🤬 \n建议是将属性命名以单下划线开头，通过这种方式来 __暗示属性是受保护的__，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。\n所以我们需要在自定义属性时 __执行一些额外的逻辑__，例如进行数据校验或转换时，就用property\n\nproperty 装饰器允许你在访问属性时 自定义其行为。 它 实际上将一个方法“伪装”成一个属性，当你访问这个属性时，实际上会调用相应的方法。\n\n需要说的一点是@property会将一个方法转换为一个只读属性，相当于定义了一个getter方法在修改内容时用修改器也就是setter方法,比如有人在修改name时, 你可以做一些手脚,还有就是setter包装的函数不需要 return!__slots__ 就是限制一个类实例可以拥有的属性，他是一个 元组 类型!\nps: 如果想在初始化时就进行检查，可以在__init__方法中添加相应的检查逻辑以下代码演示:\nclass Person:    __slots__ = ('_name', 'age')     def __init__(self, name, age):        self._name = name        self.age = age         @property    def name(self):        return self._name     @name.setter    def name(self, name):        if isinstance(name, str):            self._name = name        else:            self._name = '请输入正确名字' + '*' * 100  def main():    person = Person('小李', '18')    print(person.name)    person.name = int('54345')    print(person.name)  # 请输入正确名字*********************************************     person.age = 88  # 可以正常设置属性    person.hobby = '玩游戏'  # AttributeError: 'Person' object has no attribute 'hobby'  if __name__ == '__main__':    main()\n静态方法和类方法静态方法比较容易理解如下\n静态方法：\n\n静态方法就像一个独立的工具，它并不依赖于特定的实例或类属性。你可以把它想象成 一个独立的函数，只是碰巧它在类的内部定义了而已\n\n举个例子，如果我们有一个类代表一个工具箱，其中有一个静态方法叫做hammer()，那么你可以 直接调用这个方法，不需要先实例化一个工具箱\n\n\nfrom math import sqrt  class Triangle:    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c     @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and a + c &gt; b and b + c &gt; a     def perimeter(self):        return self._a + self._b + self._c     def area(self):        half = self.perimeter() / 2        return sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))  def main():    a, b, c = 3, 4, 5    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)        print(t.area())        print(t.perimeter())    else:        print(\"无法构成三角形\")  if __name__ == '__main__':    main() \n注意: \n要在类的实例方法中调用类的静态方法，你可以使用 self 来访问类的成员，包括静态方法。在这种情况下，self 实际上是指向类的实例本身。虽然静态方法与类的实例无关，但它们属于类的命名空间。通过 self，你可以从实例的命名空间中访问静态方法。这是一种在实例方法中访问类级别成员（包括静态方法）的通用方式。\n类方法有点难度 :\n\n类方法的第一个参数约定名为cls，它代表的是当前 类相关的信息 的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以 获取和类相关的信息并且可以创建出类的对象\n\n最后一句 \n\n获取和类相关的信息\n并且可以创建出类的对象！\n\n类方法：\n\n类方法就像一个能够访问工具箱本身的工具，但它并不依赖于具体的工具箱实例。你可以把它想象成一个能够处理工具箱的工具，但它并不关心具体是哪一个工具箱。\n\n举个例子，如果我们有一个类代表所有工具箱，其中有一个类方法叫做count_tools()，它可以统计所有工具箱中的工具数量，而不需要先实例化一个具体的工具箱。\n\n\n所以，静态方法和类方法的区别在于它们处理的数据和上下文不同。静态方法更像一个独立的工具函数，而类方法更像是能够操作整个类的工具\nfrom time import time, localtime, sleep  class Clock:     def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second     @classmethod    def new(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)     def run(self):        self._second += 1        if self._second == 60:            self._second = 0            self._minute += 1            if self._minute == 60:                self._minute = 0                self._hour += 1                if self._hour == 24:                    self._hour = 0     def show(self):        return f'当前时间：{self._hour:0&gt;2d}-{self._minute:0&gt;2d}-{self._second:0&gt;2d}'  def main():    clock = Clock.new()    while True:        print(clock.show())        clock.run()        sleep(1)        os.system('cls')  if __name__ == '__main__':    main()\n继承\n刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。\n\n关于 super().__init__() 可以参考这篇文章\nclass Person(object):    \"\"\"人\"\"\"     def __init__(self, name, age):        self._name = name        self._age = int(age)     @property    def name(self):        return self._name     @property    def age(self):        return self._age     @age.setter    def age(self, age):        self._age = age     def play(self):        print('%s正在愉快的玩耍.' % self._name)     def watch_av(self):        if self._age &gt;= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)  class Student(Person):    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade     @property    def grade(self):        return self._grade     @grade.setter    def grade(self, grade):        self._grade = grade     def study(self, course):        return f'{self._grade} 的 {self._name} 正在学习 {course}'  if __name__ == '__main__':    stu = Student('小明', '19', '高二')    print(stu.study('数学'))    stu.watch_av()\n多态\n子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。\n\nfrom abc import ABC, abstractmethod  class Pet(ABC):    \"\"\"宠物\"\"\"     def __init__(self, nickname):        self._nickname = nickname     @abstractmethod    def make_voice(self):        \"\"\"发出声音\"\"\"        pass  class Dog(Pet):    \"\"\"狗\"\"\"     def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)  class Cat(Pet):    \"\"\"猫\"\"\"     def make_voice(self):        print('%s: 喵...喵...' % self._nickname)  def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()  if __name__ == '__main__':    main()\n\n在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，__这种类的存在就是专门为了让其他类去继承它__。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。\n\n我对抽象方法的理解\n抽象方法就像是一个接口规定了一些要做的事情，但它本身并不知道如何去实现这些事情。抽象方法就好比是一份合同，规定了某个类必须提供某个方法，但不规定具体的实现。\n举个例子，想象你是一名游戏开发者，你设计了一个游戏中的角色类，每个角色都必须有一个叫做 攻击 的方法。但是，你不知道具体每个角色如何实现攻击，因为不同角色可能有不同的攻击方式。\n这时，你可以使用抽象方法来定义这个攻击方法，但不提供具体的实现。每个具体的角色（比如战士、法师、弓手等）都必须按照合同，提供自己独特的 攻击 实现。\n在这个场景下，抽象方法就是合同中的规定，而具体的角色类就是按照这个规定提供实现。这样确保了所有的角色都有攻击方法，但实现方式可以因角色而异。\n上面的代码中,无论是猫还是狗都一个共同的方法 就是make_voice 但是每个动物类对make_voice的实现方式又不同，猫有猫的叫法狗有狗的叫法，但是都会叫，这就是多态！ 用相同的方法处理不同类型的动物Pet是一个抽象类, 其中包含一个抽象方法make_voice, 猫狗都是pet，都继承了动物类，是动物的子类，都强制实现了make_voice方法， 抽象方法强制子类提供自己的实现，确保了在众多子类中都具有一致的接口，并且如果子类没有提供抽象方法的实现，或者在实例化时调用了抽象方法，将引发TypeError。\n并发编程关于并发编程建议好好读读 《Python Parallel Programming Cookbook》\n多线程实现方式多线程实现方式有两种，我喜欢用自定义线程类\n切记 要理解:\n\nt.start() : 当前线程准备就绪（等待CPU调度，具体时间是由CPU来决定）\nt.join() ：等待当前线程的任务 执行完毕 后再向下继续执行\nt.setDaemon ：守护线程（必须放在start之前）\nt.setDaemon(True)，设置为守护线程，主线程执行完毕后，子线程也自动关闭。\nt.setDaemon(False)，设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。（默认）\n\n\n\nfrom threading import Thread  class Download(Thread):    def __init__(self, filename):        self._filename = filename        super().__init__()     def run(self):        print(f'开始下载 {self._filename}')        time_to_download = random.randint(5, 10)        time.sleep(time_to_download)        print(f'下载完成 {self._filename}, 花费了{time_to_download}s')  def main():    start = time.time()    t1 = Download('鹿鼎记')    t1.start()     t2 = Download('红楼梦')    t2.start()     t1.join()    t2.join()    end = time.time()    print(f'共花费了 {end - start:.2f}s')  if __name__ == '__main__':    main()\n线程锁Lock：同步锁RLock：递归锁\n在多线程编程中，Lock和RLock（可重入锁）是用于控制多个线程对共享资源访问的工具。这两者都是互斥锁的变种，用于确保在任何给定时间内只有一个线程可以访问共享资源，以防止数据竞争和不一致的状态。\nLock\n作用： 用于在任一时刻只允许一个线程访问共享资源。\n\n特性： 一旦一个线程获取了Lock，其他线程就必须等待该线程释放锁，才能继续执行。\n\n例子： 如果一个线程获得了某个资源的Lock，那么其他线程就不能获得同一个Lock，直到这个线程释放了Lock。\n\n\nimport threading # 创建一个Locklock = threading.Lock() def example_function():    with lock:        # 临界区代码，只有一个线程能够执行这里的代码        pass\nRLock\n作用： 允许同一个线程多次获得同一个锁，避免了死锁情况。\n\n特性： 当一个线程获得了RLock后，它可以多次调用acquire，而不会阻塞，但必须相应地调用相同次数的release才能释放锁。\n\n例子： 在递归函数或嵌套调用中，RLock可以确保同一线程能够多次获取锁，而不会引起死锁。\n\n\nimport threading # 创建一个RLockrlock = threading.RLock() def example_recursive_function():    with rlock:        # 可重入锁允许同一线程多次获取锁        # 可以在嵌套调用中使用        with rlock:            pass\n总体而言，Lock和RLock都是为了保护共享资源而存在的，通过防止多个线程同时访问临界区，确保线程安全。RLock相对于Lock的特殊之处在于它允许同一个线程多次获取锁，这在某些复杂的程序结构中可能很有用。\n死锁死锁是多线程或多进程编程中常见的问题之一，它发生在两个或多个线程（或进程）互相等待对方释放资源时。简而言之，死锁是一种资源争用的情况，其中线程（或进程）之间相互等待对方释放资源，导致它们都无法继续执行。\n以下是引起死锁的一般情况：\n\n互斥条件： 资源被设计成一次只能被一个线程或进程占用，这就是互斥条件的基础。如果一个线程获得了一个资源，其他线程必须等待。\n\n占有且等待： 一个线程在持有某个资源的同时，又请求获取其他资源，并且不释放已经占有的资源。如果所有线程都采用这种策略，就可能导致死锁。\n\n无抢占： 已经获得资源的线程不能被强制释放资源，只能在自愿的情况下释放。如果一个线程在等待其他资源时不释放已经占有的资源，其他线程可能就无法继续执行，形成死锁。\n\n循环等待： 一组线程形成一个循环等待链，每个线程都在等待下一个线程持有的资源，最终导致整个系统陷入死锁。\n\n\n一个简单的例子可以说明死锁的发生。假设有两个线程 A 和 B，以如下方式请求资源：\n\nA获得资源1，等待资源2\nB获得资源2，等待资源1\n\n如果A和B同时开始执行，并且A先获得资源1，B先获得资源2，然后它们会陷入等待对方释放资源的状态，而无法继续执行。这就是一个简单的死锁场景。\n避免死锁的一般方法包括按照一定的顺序获取资源、使用超时机制、以及使用避免死锁的算法等。理解死锁的原因和常见模式是预防和解决死锁问题的关键。\n线程池\n事实上，线程的创建和释放都会带来较大的开销，频繁的创建和释放线程通常都不是很好的选择。利用线程池，可以提前准备好若干个线程，在使用的过程中不需要再通过自定义的代码创建和释放线程，而是直接复用线程池中的线程。Python 内置的concurrent.futures模块提供了对线程池的支持，代码如下所示。\n\n线程池是一种并发编程的技术，它可以有效地管理和复用线程，提高程序的性能和效率。在Python中，线程池通常使用concurrent.futures模块来实现。以下是线程池的一些基本概念和细节：\n\n线程池的创建：在Python中，你可以使用concurrent.futures.ThreadPoolExecutor来创建线程池。以下是一个简单的创建线程池的例子：\n from concurrent.futures import ThreadPoolExecutor # 创建一个拥有4个线程的线程池with ThreadPoolExecutor(max_workers=4) as executor:    # 在这里执行线程池中的任务    # ...\n\n任务提交：\n future 模式，更加强大 submit每次传的是一个！！！ 所以需要可以时用时加 不用像map一样 一次放完，结果有两种遍历方式看代码 注意如果用as_completed顺序是不定的\n你可以通过submit方法将任务提交给线程池。submit方法返回一个Future对象，你可以用来跟踪任务的状态和获取结果。\n with ThreadPoolExecutor(max_workers=4) as executor:    future = executor.submit(my_function, arg1, arg2)    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。可以通过 future.result() 获取任务的结果\n 批量提交\n with ThreadPoolExecutor() as pool:    futures = [ pool.submit(craw, url) for url in urls ] for future in futures: # 第一种 按照url的顺序 依次获取future future.result()     print(future.result())for future in as_completed(futures): # 第二种 不管哪个任务 先进行完了 就会先进行返回    print(future.result()) \n\n批量提交任务：你还可以使用map方法一次性提交多个任务，类似于map函数, 注意map的结果和入参是顺序对应的\n with ThreadPoolExecutor(max_workers=4) as executor:    results = executor.map(my_function, [arg1, arg2, arg3])    # results 是一个迭代器，包含每个任务的结果\n\nFuture对象：Future对象代表一个异步操作的结果。你可以通过它来检查任务是否完成、获取结果、取消任务等。\n with ThreadPoolExecutor(max_workers=4) as executor:    future = executor.submit(my_function, arg1, arg2)    # 检查任务是否完成    if future.done():        result = future.result()\n\n异常处理：通过add_done_callback方法，你可以指定一个回调函数，在任务完成时执行。这可以用于处理任务中的异常。\n def callback(future):    try:        result = future.result()    except Exception as e:        print(f\"Exception: {e}\") with ThreadPoolExecutor(max_workers=4) as executor:    future = executor.submit(my_function, arg1, arg2)    future.add_done_callback(callback)\n callback 函数接受的 future 参数是通过 add_done_callback 方法自动传递的。这个方法会在异步任务完成时被调用，将 concurrent.futures.Future 对象作为参数传递给注册的回调函数。所以，callback 函数的参数 future 实际上是对应异步任务的 Future 对象，它包含了异步任务的状态和结果信息。通过 future.result()，可以获取异步任务的执行结果，即下载的响应对象，进行后续的处理。\n\n回调函数：\n 当你使用 future.add_done_callback(callback) 时，你告诉程序：“当这个 future 完成时，请调用 callback 函数。” \n 然而，有时候你的 callback 函数可能需要除了 future 之外的额外信息或参数。这时，你可以通过以下方式传递额外的参数：\n\n使用lambda函数：\n\n 你可以创建一个小型的匿名函数（lambda 函数），这个函数接受 future 作为参数，然后调用你的 callback 函数并传递额外的参数。这是一种简洁的方式。\n extra_param = \"some_value\"future.add_done_callback(lambda future: callback(future, extra_param))\n\n使用functools.partial：\n\n 如果你觉得 lambda 函数语法有点冗长，你可以使用 functools.partial，它可以创建一个新的函数，固定住部分参数。在这里，我们将 callback 与额外的参数绑定在一起，然后将这个新的函数传递给 add_done_callback。\n from functools import partial extra_param = \"some_value\"callback_with_params = partial(callback, extra_param)future.add_done_callback(callback_with_params)\n\n 这两种方法都能达到同样的目的，即在 callback 函数被调用时，确保额外的参数也能被传递给它。选择其中一种方法通常取决于你个人的偏好和代码的风格。\n\nPS: 第二种方法按关键词参数传递 🤬 后面写代码时发现的小问题， 不然callback_with_params会把extra_param当作future 即callback_with_params = partial(callback, param = extra_param) 固定多个参数也是如此\n\n\n关闭线程池：在使用完线程池后，最好通过shutdown方法来关闭它。这将确保所有的线程都被正确终止。当然如果使用上下文管理方式不用\n def task(video_url):print(\"开始执行任务\", video_url)time.sleep(5)pool = ThreadPoolExecutor(10)url_list = [\"www.xxxx-{}.com\".format(i) for i in range(300)]for url in url_list:    pool.submit(task, url)print(\"执行中...\")pool.shutdown(True)  # 等待线程池中的任务执行完毕后，在继续执行print('继续往下走')\n\n请注意，尽管线程池可以提高并发性，但在某些情况下，由于Python的全局解释器锁（GIL），线程并不能充分利用多核处理器。如果你需要更好的并行性能，可以考虑使用concurrent.futures.ProcessPoolExecutor，它使用多个进程而不是线程。\n示例\nimport requestsfrom lxml import etreefrom concurrent.futures import ThreadPoolExecutor urls = [    f'https://www.cnblogs.com/#p{page}'    for page in range(1, 51)]  def craw(url):    response = requests.get(url)    response.encoding = 'utf-8'    page_text = response.text    return page_text  def parse(html):    tree = etree.HTML(html)    names = tree.xpath('//*[@id=\"post_list\"]/article/section/div/a/text()')    for name in names:        fout.write(str(name) + '\\n')  ## start = time.time()# with ThreadPoolExecutor(max_workers=10) as pool:#     craw_futures = [pool.submit(craw, url) for url in urls]# end = time.time()# print(f'craw完成- {end - start} s')## start = time.time()# with ThreadPoolExecutor(max_workers=10) as executor:#     fout = open('./q1.txt', 'w', encoding='utf-8')#     for craw_future in craw_futures:#         html = craw_future.result()#         parse_future = executor.submit(parse, html)# end = time.time()# print(f'parse完成- {end-start} s') # 增加回调函数def parse(craw_future):    html = craw_future.result()    tree = etree.HTML(html)    names = tree.xpath('//*[@id=\"post_list\"]/article/section/div/a/text()')    for name in names:        fout.write(str(name) + '\\n')  start = time.time()with ThreadPoolExecutor(max_workers=10) as pool:    fout = open('./q1.txt', 'w', encoding='utf-8')    craw_futures = [pool.submit(craw, url) for url in urls]    for craw_future in craw_futures:        craw_future.add_done_callback(parse)fout.close()end = time.time()print(f'全部完成- {end - start} s')\n","categories":["Python"],"tags":["Python"]},{"title":"Learn Regex","url":"/2023/04/09/Learn-Regex/","content":"\n什么是正则表达式？\n正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n\n\n\n \n\n1. 基本匹配正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式the，它表示一个规则：由字母t开始，接着是h，再接着是e。\neg:\"the\" =&gt; The fat cat sat on the mat.\n2. 元字符正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\n\n\n\n元字符\n描述\n\n\n\n.\n句号匹配任意单个字符除了换行符\n\n\n[ ]\n字符种类, 匹配方括号内的任意字符。\n\n\n[^ ]\n否定的字符种类, 匹配除了方括号里的任意字符\n\n\n*\n匹配&gt;=0个重复的在*号之前的字符\n\n\n+\n匹配&gt;=1个重复的+号前的字符\n\n\n{n,m}\n匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).\n\n\n(xyz)\n字符集，匹配与 xyz 完全相等的字符串.\n\n\n|\n或运算符，匹配符号前或后的字符.\n\n\n\\\n转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ |\n\n\n^\n从开始行开始匹配.\n\n\n$\n从末端开始匹配.\n\n\n2.1 点运算符.是元字符中最简单的例子, .匹配任意单个字符，但不匹配换行符.例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。\n“.ar“ =&gt; The car parked in the garage.\n2.2 字符集字符集也叫做字符类. 方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. 在方括号中的字符集 不关心顺序 .例如，表达式[Tt]he 匹配 the 和 The\n\"[Tt]he\" =&gt; The car parked in the garage.\n2.2.1 否定字符集一般来说^表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的 例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。\n\"[^c]ar\" =&gt; The car parked in the garage.\n2.3 重复次数后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数 这些元字符在不同的情况下有着不同的意思.\n测试！！！！！！！！！\n","categories":["随笔"],"tags":["Regex"]},{"title":"Python GUI之Tkinter","url":"/2023/04/27/Python-GUI%E4%B9%8BTkinter/","content":"\nTkinter是什么？\n\nTkinter是Python标准GUI工具包的接口，用于窗口视窗设计。它是Python自带的GUI界面，可以编辑，实现直观的功能。\n\n\n对于有GUI编程经验的人来说，Tkinter十分简单。Python的GUI库很多，但选择Tkinter最为简单，因为它是自带库，无需下载安装，并且Python作为脚本语言，在开发小工具时需要具备界面，并且Tkinter足够胜任。本文主要概述和实践Tkinter编程，为GUI编程新手树立基本概念，并且展示如何实现小的图形窗口功能。\n(以下内容转载)\n\n对于Tkinter编程，可以用两个比喻来理解：\n\n第一个，作画。我们都见过美术生写生的情景，先支一个画架，放上画板，蒙上画布，构思内容，用铅笔画草图，组织结构和比例，调色板调色，最后画笔勾勒。相应的，对应到tkinter编程，那么我们的显示屏就是支起来的画架，根窗体就是画板，在tkinter中则是Toplevel，画布就是tkinter中的容器（Frame），画板上可以放很多张画布（Convas），tkinter中的容器中也可以放很多个容器，绘画中的构图布局则是tkinter中的布局管理器（几何管理器），绘画的内容就是tkinter中的一个个小组件，一幅画由许多元素构成，而我们的GUI界面，就是有一个个组件拼装起来的，它们就是widget。\n第二个，我们小时候都玩过积木，只要发挥创意，相同的积木可以堆出各种造型。tkinter的组件也可以看做一个个积木，形状或许不同，其本质都是一样的，就是一个积木，不管它长什么样子，它始终就是积木！所以这些小组件都有许多共性，另外，个人认为，学习界面编程，最重要的不是一开始学习每个积木的样子，不是学习每个组件怎么用，而是这些组件该怎么放。初始学习中，怎么放远远比怎么用重要的多。网上有大量的文章资料，基本全是介绍组件怎么用的，对于怎么放，也就是tkinter中的布局管理器，都是一笔带过，这对初学者有点本末倒置，或许绝大部分是转载的原因吧，极少是自己真正写的。组件怎么用不是最迫切的，用到的时候再去了解也不迟，边用边学反而更好。因此我将专门写一章，详细介绍布局管理器的使用。\n\n\nTkinter 控件详细介绍\n1.Tkinter 模块元素简要说明\nThe Button WidgetThe Canvas WidgetThe Checkbutton WidgetThe Entry WidgetThe Frame WidgetThe Label WidgetThe LabelFrame WidgetThe Listbox WidgetThe Menu WidgetThe Menubutton WidgetThe Message WidgetThe OptionMenu WidgetThe PanedWindow WidgetThe Radiobutton WidgetThe Scale WidgetThe Scrollbar WidgetThe Spinbox WidgetThe Text WidgetThe Toplevel WidgetBasic Widget MethodsToplevel Window Methods\n\n2.常用窗口部件及简要说明Tkinter支持16个核心的窗口部件，这个16个核心窗口部件类简要描述如下：\n\n\n\n编号\n控件\n作用\n\n\n\n1\nLabel\n标签控件 -&gt; 显示文本跟位图\n\n\n2\nButton\n按钮控件 -&gt; 在程序中显示按钮,用来执行一个命令或别的操作\n\n\n3\nEntry\n输入控件 -&gt; 用于显示简单的文本内容\n\n\n4\nText\n文本控件 -&gt; 用于显示多行文本 格式化文本显示,允许你用不同的样式和属性来显示和编辑文本,同时支持内嵌图象和窗口\n\n\n5\nListbox\n列表框控件 -&gt; 显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为\n\n\n6\nRadioButton\n单选按钮控件 -&gt; 代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton\n\n\n7\nCheckbutton\n多选框控件 -&gt; 代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换。\n\n\n8\nScale\n范围控件 -&gt; 显示一个数值刻度，允许你通过滑块来设置一数字值。\n\n\n9\nCanvas\n画布控件 -&gt; 用来绘制图表和图，创建图形编辑器，实现定制窗口部件。\n\n\n10\nMenu\n菜单控件 -&gt; 菜单条,用来实现下拉和弹出式菜单。\n\n\n11\nFrame\n框架控件 -&gt; 在屏幕上显示一个矩形区域，多用来作为容器 / 一个容器窗口部件。帧可以有边框和背景，当创建一个应用程序或dialog(对话)版面时，帧被用来组织其它的窗口部件。\n\n\n12\nmessageBox\n‘窗口控件’ -&gt; 消息框，用于显示你应用程序的消息框\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n实践1.窗口及Label部件\n我们要学习使用上面提到的这些控件首先要创建一个主窗口，就像作画一样，先要架好架子和画板，然后才能在上面放画纸和各种绘画元素，创建好主窗口才能在上面放置各种控件元素。而创建过程是很简单的，如下：\n\nimport tkinter as tk# 1. 实例化一个Obj，建立窗口windowwindow = tk.Tk()# 2. 给窗口起名字window.title(\"My first window\")# 3. 设定窗口大小(长x宽) 这里的乘是小xwindow.geometry('300x300')# 4. 给图形界面设定标签l1 = tk.Label(window, text=\"打标签\", bg='yellow', font=('Arial', 12), width=10, height=2)# bg:背景，font:字体，width:长，height:高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高# 5. 放置标签l1.pack()# Label内容content区域放置位置，自动调节尺寸. 放置lable的方法有：1）l.pack(); 2)l.place();# 6. 主窗口循环显示window.mainloop()# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环# 所有的窗口文件都必须有类似的mainloop函数，mainloop是窗口文件的关键的关键。\n测试效果:\n\n2.Button窗口部件简单说明：\n\nButton（按钮）部件是一个标准的Tkinter窗口部件，用来实现各种按钮。按钮能够包含文本或图象，并且你能够将按钮与一个Python函数或方法相关联。当这个按钮被按下时，Tkinter自动调用相关联的函数或方法。\n\n按钮仅能显示一种字体，但是这个文本可以跨行。另外，这个文本中的一个字母可以有下划线，例如标明一个快捷键。默认情况，Tab键用于将焦点移动到一个按钮部件。\n什么时候用按钮部件?简言之，按钮部件用来让用户说“马上给我执行这个任务”，通常我们用显示在按钮上的文本或图象来提示。按钮通常用在工具条中或应用程序窗口中，并且用来接收或忽略输入在对话框中的数据。关于按钮和输入的数据的配合，可以参看Checkbutton和Radiobutton部件。\n如何创建?普通的按钮很容易被创建，仅仅指定按钮的内容（文本、位图、图象）和一个当按钮被按下时的回调函数即可：b = tk.Button(window, text=”hit me”, command=hit_me)\n没有回调函数的按钮是没有用的，当你按下这个按钮时它什么也不做。你可能在开发一个应用程序的时候想实现这种按钮，比如为了不干扰你的beta版的测试者：b = tk.Button(window, text=”Help”, command=DISABLED)\n\n\n代码如下\nwindow = tk.Tk()window.title(\"button learn\")window.geometry('300x300')var = tk.StringVar()# 将label标签的内容设置为字符类型，用var来接收hit_me函数的传出内容用以显示在标签上l1 = tk.Label(window, textvariable=var, bg='green', fg='red', font=(\"Arial\", 12), width=30, height=2)l1.pack()# 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名on_hit = Falsedef hit_me():    global on_hit    if on_hit == False:        on_hit = True        var.set('you hit me')    else:        on_hit = False        var.set('')b = tk.Button(window, text=\"hit me\", font=(\"Arial\", 12), width=30, height=2, command=hit_me)b.pack()window.mainloop()\n\n效果图如下:\n点击后\n\n3.Entry窗口部件简单说明：　　\n\nEntry是tkinter类中提供的的一个单行文本输入域，用来输入显示一行文本，收集键盘输入(类似 HTML 中的 text)。\n\n什么时候用?需要用户输入用户信息时，比如我们平时使用软件、登录网页时，用户交互界面让我们登录账户信息等时候可以用到。\n\n\n代码\nwindow = tk.Tk()window.title(\"Entry learn\")window.geometry('300x300')lambda_login = tk.Label(window, text='模拟登录', width=20, height=1)lambda_login.pack()# 在图形界面上设定输入框控件entry并放置控件account = tk.Entry(window, show=None, font=(\"Arial\", 12))  # show设为None显示成明文形式account.pack()password = tk.Entry(window, show='*', font=(\"Arial\", 12))password.pack()def check_button():    \"\"\"    当登录按钮被点击时触发此函数    :return:    \"\"\"    name = account.get()    pwd = password.get()    msg = f'用户名:{name}\\n密码:{pwd}'    messagebox.showinfo(title='登录提示', message=msg)button = tk.Button(window, text='登录', width=15, height='2', command=check_button)button.pack()window.mainloop()\n\n效果图如下\n4.Text窗口部件简单说明：　　\n\nText是tkinter类中提供的的一个多行文本区域，显示多行文本，可用来收集(或显示)用户输入的文字(类似 HTML 中的 textarea)，格式化文本显示，允许你用不同的样式和属性来显示和编辑文本，同时支持内嵌图象和窗口。(Entry 只能输入一行文字，如果想要输入多行文字，需要使用Text文本控件)\n\n什么时候用?在需要显示编辑用户、产品多行信息时，比如显示用户详细描述文字，产品简介等等，支持随时编辑。\n\n\n代码\n# Textwindow = tk.Tk()window.title(\"Text learn\")window.geometry(\"300x300\")e = tk.Entry(window, show=None)e.pack()def insert_point():    var = e.get()    t.insert(\"insert\", var)def insert_end():    var = e.get()    t.insert(\"end\", var)b1 = tk.Button(window, text=\"insert point\", width=10, height=2, command=insert_point)b1.pack()b2 = tk.Button(window, text=\"insert end\", width=10, height=2, command=insert_point)b2.pack()t = tk.Text(window, height=3)t.pack()window.mainloop()\n\n创建文本框时，可以指定高度，如果你输入的内容超过了这个高度，它会自动向上滚动，和Entry不同，想要获取文本框里的所有输入的内容，必须用这样的语句才行text = t.get(\"0.0\", \"end\")\n效果图如下\n5.Listbox窗口部件简单说明：　　\n\nText是tkinter类中提供的的列表框部件，显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为。\n\n什么时候用?在有一个很多内容选项组成的列表提供用户选择时会用到。\n\n\n代码\nwindow = tk.Tk()window.title(\"ListBox learn\")window.geometry(\"300x300\")list_items = tk.StringVar()list_items.set(('python', 'Jave', 'C语言'))lb = tk.Listbox(window, listvariable=list_items)lb.pack()no_select = \"没有选中任何选项\"def check_button():    select = lb.curselection()  # 获取被选中的可选项的索引    print(len(select))    if len(select) == 0:        label_text.set(no_select)    else:        text = lb.get(select)        label_text.set(f\"你已选择{text}\")button = tk.Button(window, text=\"显示所选\", width='15', height=1, command=check_button)button.pack()label_text = tk.StringVar()label_text.set(no_select)label = tk.Label(window, width=15, height=2, textvariable=label_text)label.pack()window.mainloop()\n效果图如下:\n\n6.Radiobutton窗口部件简单说明：　　\nListBox可以提供若干可选项供用户选择，此外，RadioButton也可以实现相同的功能.\n\nRadiobutton：代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton。\n\n什么时候用?在有一个很多内容选项组成的选项列表提供用户选择时会用到，用户一次只能选择其中一个，不能多选。\n\n\n\n本节通过var对象获取了被选中的单选按钮的值，然后使用label的config方法修改标签上的显示文字，现在你又学会一种修改标签文字内容的方法\n\n代码\nwindow = tk.Tk()window.title(\"RadoiButton Learn\")window.geometry(\"300x300\")var = tk.StringVar()  # 定义一个var用来将radiobutton的值和Label的值联系在一起label = tk.Label(window, width=15, height=2, bg='green', text=\"\")label.pack()def select():    label.config(text=f\"你选择了{var.get()}\")r1 = tk.Radiobutton(window, text='Python', variable=var, value='python', command=select)r1.pack()r2 = tk.Radiobutton(window, text='Java', variable=var, value='Java', command=select)r2.pack()r3 = tk.Radiobutton(window, text='C语言', variable=var, value='C语言', command=select)r3.pack()window.mainloop()\n\n效果图如下:\n\n7.Checkbutton窗口部件前面学习了ListBox,RadioButton,他们都提供了让用户做选择的功能，Checkbutton同样可以提供这样的选择功能，而且，它是 多选 的\n简单说明：　　\n\nCheckbutton：代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换，选择和取消选择。\n\n什么时候用?在有一个很多内容选项组成的选项列表提供用户选择时会用到，用户一次可以选择多个。\n\n\n代码\n# CheckButtonwindow = tk.Tk()window.title(\"CheckButton Learn\")window.geometry(\"300x300\")label = tk.Label(window, width=30, height=2, bg='green', text='')label.pack()var1 = tk.IntVar()var2 = tk.IntVar()var3 = tk.IntVar()def select():    select_list = []    if var1.get() == 1:        select_list.append('Python')    if var2.get() == 1:        select_list.append('Java')    if var3.get() == 1:        select_list.append('C语言')    text = f\"你选择了{','.join(select_list)}\"    label.config(text=text)c1 = tk.Checkbutton(window, text='Python', variable=var1, onvalue=1, offvalue=0, command=select)c2 = tk.Checkbutton(window, text='Java', variable=var2, onvalue=1, offvalue=0, command=select)c3 = tk.Checkbutton(window, text='C语言', variable=var3, onvalue=1, offvalue=0, command=select)c1.pack()c2.pack()c3.pack()window.mainloop()\n\n效果图如下:\n\n8.Scale窗口部件简单说明：　　\n\nScale： 尺度（拉动条），允许你通过滑块来设置一数字值。\n\n什么时候用?在需要用户给出评价等级，或者给出一个评价分数，或者拉动滑动条提供一个具体的数值等等。\n\n\n代码\n# Scalewindow = tk.Tk()window.title(\"Scale Learn\")window.geometry('300x300')label = tk.Label(window, width=20, height=2, bg='green', text=\"请滑动选择🙂\")label.pack()def select(var):    label.config(text=f'你选择的是{var}')scale = tk.Scale(window, label=\"可选范围\", from_=0, to=10, orient=tk.HORIZONTAL, length=400, tickinterval=2,                 resolution=0.1, command=select)# 从0到10,刻度为2，orient设置横向显示，length长度scale.pack()window.mainloop()\n\n效果图如下:\n\n9.Canvas窗口部件你可以在Canvas 画各种图形，也可以展示图片，同时，你还可以移动他们\n\n简单说明：　　Canvas：画布，提供绘图功能(直线、椭圆、多边形、矩形) 可以包含图形或位图，用来绘制图表和图，创建图形编辑器，实现定制窗口部件。\n\n什么时候用?在比如像用户交互界面等，需要提供设计的图标、图形、logo等信息是可以用到画布。\n\n\n\n画一条对角线代码window = tk.Tk()window.title(\"Canvas Learn_画布\")window.geometry(\"500x400\")canvas = tk.Canvas(window, bg='pink', height=300, width=150)canvas.pack()line = canvas.create_line(0, 0, 150, 300)window.mainloop()\n\n效果图如下:\n&amp;: \n\n使用create_line创建一条直线时，需要指定4个坐标，分别是x1, y1, x2, y2, (x1, y1) 是起始点坐标，(x2, y2)是结束点坐标。\n在所有图形界面中, 左上角的坐标值是(0, 0), 以此为原点开展坐标系！👉X轴,👇y轴\n\n\n画出圆形，长方形代码window = tk.Tk()window.title(\"Canvas Learn 2\")window.geometry(\"500x400\")canvas = tk.Canvas(window, bg='pink', height=300, width=200)canvas.pack()oval = canvas.create_oval(75, 75, 150, 150, fill='red')rect = canvas.create_rectangle(75, 175, 125, 250, fill='Purple')window.mainloop()\n效果图如下:\n\n\n&amp;: \n\ncreate_rectangle方法里，前两个参数决定了长方形的左上角坐标，后两个参数决定了长方形的右下角坐标。\ncreate_oval方法并不是只能用来画圆形，椭圆形也可以，这完全取决于传入的参数如下\n\n\n图形移动代码window = tk.Tk()window.title(\"Canvas Learn 3\")window.geometry(\"500x400\")canvas = tk.Canvas(window, width=300, height=300, bg='pink')canvas.pack()oval = canvas.create_oval(100, 100, 150, 150, fill='Purple')def movie():    canvas.move(oval, 50, 25)button = tk.Button(window, text=\"点此移动⚪\", command=movie)button.pack()window.mainloop()\n效果图如下:\n\n\n\n展示图片代码window = tk.Tk()window.title(\"Canvas Learn 4\")window.geometry(\"600x400\")canvas = tk.Canvas(window, height=330, width=510, bg=\"pink\")canvas.pack()image_file = ImageTk.PhotoImage(file='./8a81ecd8fdd266b3221da325875c0ea8.gif')image = canvas.create_image(10, 10, anchor='nw', image=image_file)window.mainloop()\n效果图如下:\n\n&amp;:\n\ntkinter自己的PhotoImage只支持gif格式的图片，因此，我们需要使用PIL的ImageTk，这样，所有格式的图片都可以显示\n10：图片的x坐标，表示图片左上角的位置在canvas上距离左边界的距离。\n10：图片的y坐标，表示图片左上角的位置在canvas上距离上边界的距离。\nanchor=’nw’：指定锚点的位置，这里是左上角，即北西角。\nimage=image_file：指定图片的内容，图片文件必须是一个有效的图片文件对象（比如PNG、JPEG、GIF等格式的图片）。在这个例子中，image_file是之前打开并加载的一个图片文件对象。create_image()会载入这个图片，并在canvas中显示出来。\n需要注意的是，create_image()函数返回一个整数对象，这个对象代表了在canvas上创建的图片的标识符，你可以使用这个标识符来操作这个图片对象。例如，你可以使用move()函数将图片移到新的位置，使用delete()函数删除这个图片对象等。同时，如果你想要在canvas中显示不止一张图片，你可以多次调用create_image()函数来创建多个图片对象，每个对象都会返回一个不同的标识符，这样你就可以对它们进行独立的控制和操作。\n图片锚定点位置参数图\n\n10.Menu窗口部件简单说明：　　\n\nMenu：菜单条，用来实现下拉和弹出式菜单，点下菜单后弹出的一个选项列表,用户可以从中选择\n\n什么时候用?在比如像软件或网页交互界面等，需要提供菜单选项功能提供用户选择菜单选项功能时用到。\n\n\n代码\n# Menuwindow = tk.Tk()window.title(\"Menu Learn\")window.geometry(\"600x400\")label = tk.Label(window, text='$', height='300', width='400', bg='pink')label.pack()counter = 0def do_job():    global counter    label.config(text=f\"do -&gt; {str(counter)}\")    counter += 1menubar = tk.Menu(window)  # 先创建菜单栏！# 已经创建好了菜单栏！ 开始填充# 创建一个File菜单项（默认不下拉，下拉内容包括New，Open，Save，Exit功能项） 此时menubar是画板file_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label='File', menu=file_menu)file_menu.add_command(label='New', command=do_job)file_menu.add_command(label='Open', command=do_job)file_menu.add_command(label='Save', command=do_job)# 添加一条分割线file_menu.add_separator()file_menu.add_command(label='Exit', command=window.quit())  # 用tkinter里面自带的quit()函数# 创建Edit菜单项edit_menu = tk.Menu(menubar, tearoff=0)  # 此时menubar是画板menubar.add_cascade(label='Edit', menu=edit_menu)edit_menu.add_command(label='Cut', command=do_job)edit_menu.add_command(label='Copy', command=do_job)edit_menu.add_command(label='Paste', command=do_job)# 创建二级菜单 此处想象画板 此时画板成了一级菜单submenu = tk.Menu(file_menu, tearoff=0)file_menu.add_cascade(label='Import', menu=submenu, underline=0)submenu.add_command(label='Submenu_1', command=do_job)# 创建菜单栏完成后，配置让菜单栏menubar显示出来window.config(menu=menubar)# 主窗口循环显示window.mainloop()\n\n效果图如下:\n\n11.Frame窗口部件简单说明：　　\n\nFrame：框架，用来承载放置其他GUI元素，就是一个容器，是一个在 Windows 上分离小区域的部件, 它能将 Windows 分成不同的区,然后存放不同的其他部件. 同时一个 Frame 上也能再分成两个 Frame, Frame 可以认为是一种容器.\n\n什么时候用?在比如像软件或网页交互界面等，有不同的界面逻辑层级和功能区域划分时可以用到，让交互界面逻辑更加清晰。\n\n\n\n前面每一讲介绍一个控件，所举的例子都没有考虑界面的布局，所有控件都挤在一起，本篇所将的frame控件，就是被用来布局使用的，一个frame就是一个矩形框，在一个window上，你可以排放多个frame，一个frame上又可以摆放多个frame，这样就可以将一个界面划分出多个区域，frame也是容器，前面讲的那些控件都可以放在frame上面。\n\n代码\n# Framewindow = tk.Tk()window.title('Frame Learn')window.geometry('300x300')# 和前面部件分开创建和放置不同，其实可以创建和放置一步完成!!!tk.Label(window, bg='pink', text='On the window', font=('Arial', 16)).pack()frame = tk.Frame(window)frame.pack()# 此刻以frame为画板frame_l = tk.Frame(frame)frame_r = tk.Frame(frame)frame_l.pack(side='left')frame_r.pack(side='right')# 创建三组标签tk.Label(frame_l, text='on the frame_l1', bg='green').pack()tk.Label(frame_l, text='on the frame_l2', bg='green').pack()tk.Label(frame_l, text='on the frame_l3', bg='green').pack()tk.Label(frame_r, text='on the frame_r1', bg='red').pack()tk.Label(frame_r, text='on the frame_r2', bg='red').pack()tk.Label(frame_r, text='on the frame_r3', bg='red').pack()window.mainloop()\n\n效果图如下:\n\n12.messageBox窗口部件简单说明：　　\n\nmessageBox：消息框，用于显示你应用程序的消息框。(Python2中为tkMessagebox)，其实这里的messageBox就是我们平时看到的弹窗。 我们首先需要定义一个触发功能，来触发这个弹窗，这里我们就放上以前学过的button按钮，通过触发功能，调用messagebox吧，点击button按钮就会弹出提示对话框。下面给出messagebox提示信息的几种形式：\n\ntkinter.messagebox.showinfo(title='Hi', message='你好！')            # 提示信息对话窗tkinter.messagebox.showwarning(title='Hi', message='有警告！')       # 提出警告对话窗tkinter.messagebox.showerror(title='Hi', message='出错了！')         # 提出错误对话窗print(tkinter.messagebox.askquestion(title='Hi', message='你好！'))  # 询问选择对话窗return 'yes', 'no'print(tkinter.messagebox.askyesno(title='Hi', message='你好！'))     # return 'True', 'False'print(tkinter.messagebox.askokcancel(title='Hi', message='你好！'))  # return 'True', 'False'\n\n\n什么时候用?在比如像软件或网页交互界面等，有不同的界面逻辑层级和功能区域划分时可以用到，让交互界面逻辑更加清晰。\n\n代码\n# messageboxwindow = tk.Tk()window.title(\"Messagebox Learn\")window.geometry(\"600x400\")def hit():    # tk.messagebox.showinfo(title='Info', message='show Info : \\nxxx')    # tk.messagebox.showinfo(title='Warn', message='show Warn : \\nxxx')    # tk.messagebox.showinfo(title='Error', message='show Error: \\nxxx')    tk.messagebox.askyesno(title='Ask question', message='傻子!')    tk.messagebox.askyesno(title='Yes or No', message='you are bendan')    tk.messagebox.askokcancel(title='True or False', message='you are bendan')button = tk.Button(window, text='try hit me', bg='pink', command=hit)button.pack()window.mainloop()\n\n效果如下:\n\n&amp;:\n注意：上面的print()不是必须的， print只是在控制台打印return的值\n13.布局 - pack/grid/place简要说明\n\n让控件出现在你期望的位置上，有三个方法，一个比一个精确\n\nPack：The Pack Geometry Managerpack 可以指定上下左右\n代码\nwindow = tk.Tk()window.title(\"pgp Learn\")window.geometry(\"600x400\")tk.Label(window, text='N', fg='pink', font=('Arial', 20)).pack(side='top')tk.Label(window, text='S', fg='pink', font=('Arial', 20)).pack(side='bottom')tk.Label(window, text='W', fg='pink', font=('Arial', 20)).pack(side='left')tk.Label(window, text='E', fg='pink', font=('Arial', 20)).pack(side='right')window.mainloop()\n\n效果图如下:\n\nGrid：The Grid Geometry Managergrid 是方格, 所以所有的内容会被放在这些规律的方格中。如下\nfor i in range(3):    for j in range(3):        tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)\n以上的代码就是创建一个三行三列的表格，其实 grid 就是用表格的形式定位的。这里的参数 row 为行，colum 为列，padx 就是单元格左右间距，pady 就是单元格上下间距，ipadx是单元格内部元素与单元格的左右间距，ipady是单元格内部元素与单元格的上下间距。\n参数解释:\n\nrow=i：设置 Label 所在的行号为 i，第一行为 0。\ncolumn=j：设置 Label 所在的列号为 j，第一列为 0。\npadx=10：设置 Label 的内部水平留白大小为 10 point。\npady=10：设置 Label 的内部垂直留白大小为 10 point。\nipadx=10：设置 Label 相对于其父容器水平方向上额外的 padding 。也就是在 padx 的基础上再添加额外的 padding。\nipady=10：设置 Label 相对于其父容器垂直方向上额外的 padding。也就是在 pady 的基础上再添加额外的 padding。\n\n代码\nwindow = tk.Tk()window.title(\"pgp Learn\")window.geometry(\"600x400\")for i in range(1, 6):    for j in range(1, 6):        tk.Label(window, text=1).grid(row=i, column=j, padx=10, pady=10, ipadx=10, ipady=10)window.mainloop()\n\n效果图如下:\nPlace：The Place Geometry Manager简要说明\n\n在3个设置空间位置的方法中，place是最灵活的，因为它直接指定了空间出现的位置如此处给的(50, 100)，就是将这个部件放在坐标为(x=50, y=100)的这个位置, 后面的参数 anchor=’nw’，就是前面所讲的锚定点是西北角。例如：\n\ntk.Label(window, text='Pl', font=('Arial', 20), ).place(x=50, y=100, anchor='nw')\n\n代码\nwindow = tk.Tk()window.title(\"pgp Learn\")window.geometry(\"600x400\")tk.Label(window, text='Place', fg='pink', font=('Arial', 20)).place(x=50, y=50, anchor='nw')window.mainloop()\n\n效果图如下:\n\n本文学习主要来源以下文章\n\nPython GUI之tkinter窗口视窗教程大集合（看这篇就够了）\nPython GUI之tkinter教程\n\n","categories":["随笔"],"tags":["Hexo","Keep"]},{"title":"Requests","url":"/2023/12/30/Requests/","content":"requests系列小知识点\n\nurl参数编码和解码\n\nfrom urllib.parse import quote, unquote encoded_string = \"问题小记\"decoded_string = quote(encoded_string)print(decoded_string) encoded_string = \"%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0\"decoded_string = unquote(encoded_string)print(decoded_string)\n请求发送请求头\n\n\nHost\n(主机和端口号)\n\n\n\nConnection\n(链接类型)\n\n\nUpgrade-Insecure-Requests\n(升级为HTTPS请求)\n\n\nUser-Agent\n(浏览器名称)\n\n\nAccept\n(传输文件类型)\n\n\nReferer\n(页面跳转处)\n\n\nAccept-Encoding\n（文件编解码格式）\n\n\nCookie\n（Cookie）\n\n\nx-requested-with\nXMLHttpRequest (表示该请求是Ajax异步请求)\n\n\n请求方法作用：让协议清楚的知道，客户端发送了一个什么类型的‘动作指令’\n\n\n\n方 法\n描 述\n\n\n\nGET\n请求页面，并返回页面内容\n\n\nHEAD\n类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头\n\n\nPOST\n大多用于提交表单或上传文件，数据包含在请求体中\n\n\nPUT\n从客户端向服务器传送的数据取代指定文档中的内容\n\n\nDELETE\n请求服务器删除指定的页面\n\n\nCONNECT\n把服务器当作跳板，让服务器代替客户端访问其他网页\n\n\nOPTIONS\n允许客户端查看服务器的性能\n\n\nTRACE\n回显服务器收到的请求，主要用于测试或诊断\n\n\nget\nurl (必需参数):\n用于指定请求的目标 URL。\n\n\n\nimport requests url = \"https://www.example.com\"response = requests.get(url)\n\nparams:\n用于传递 URL 查询参数。可以是一个字典或一个字符串。\n\n\n\npayload = {'key1': 'value1', 'key2': 'value2'}response = requests.get(url, params=payload)\n\nheaders:\n用于设置 HTTP 请求头，其中包含关于请求的信息，如用户代理、接受类型等。\n\n\n\nheaders = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}response = requests.get(url, headers=headers)\n\ncookies:\n用于传递 cookie。\n\n\n\ncookies = {'cookie_name': 'cookie_value'}response = requests.get(url, cookies=cookies)\n\nauth:\n用于设置 HTTP 认证信息，可以是元组 (username, password)。\n\n\n\nauth = ('username', 'password')response = requests.get(url, auth=auth)\n\ntimeout:\n设置请求超时时间，以秒为单位。\n\n\n\nresponse = requests.get(url, timeout=5)\n\nallow_redirects:\n指定是否允许重定向，默认为 True。\n\n\n\nresponse = requests.get(url, allow_redirects=False)\n\nproxies:\n用于设置代理。\n\n\n\nproxies = {'http': 'http://proxy.example.com', 'https': 'https://proxy.example.com'}response = requests.get(url, proxies=proxies)\n\nstream:\n如果设置为 True，则会立即下载响应内容的一部分，并且可以通过迭代器逐步获取剩余的内容。\n\n\n\nresponse = requests.get(url, stream=True)for chunk in response.iter_content(chunk_size=128):    print(chunk)\n\nverify:\n用于控制是否进行 SSL 证书验证。默认为 True，可以设置为 False 关闭验证，或者指定一个证书路径。\n\n\n\nresponse = requests.get(url, verify='/path/to/certfile.pem')\n\ncert:\n用于指定客户端证书文件路径，通常是一个包含证书和私钥的元组。\n\n\n\nresponse = requests.get(url, cert=('/path/to/client.cert', '/path/to/client.key'))\n\nparams和data:\nparams 用于设置 URL 查询参数，而 data 用于设置请求体中的数据，适用于 POST 请求。\n\n\n\npayload = {'key1': 'value1', 'key2': 'value2'}response = requests.get(url, params=payload) # 或者在 POST 请求中使用 data 参数data = {'key1': 'value1', 'key2': 'value2'}response = requests.post(url, data=data)\n\nhooks:\n用于自定义回调钩子，可以在请求的不同阶段执行自定义的逻辑，比如在发送请求之前或接收响应之后。\n\n\n\ndef custom_hook(response, *args, __kwargs):    print(\"Custom hook executed\") hooks = {'response': custom_hook}response = requests.get(url, hooks=hooks)\n\nparams和headers中的特殊字符处理:\n如果 URL 中包含特殊字符，可以使用 quote 函数进行编码。\n\n\n\nfrom urllib.parse import quote url = \"https://www.example.com/search\"search_query = \"hello world\"url_with_query = url + \"?q=\" + quote(search_query)response = requests.get(url_with_query)\n这些是一些常见和不太常见但有用的参数。在实际使用中，根据具体的需求，可以查阅 requests 官方文档 获取更多详细信息。\npostrequests.post() 是用于发送 HTTP POST 请求的函数，与 requests.get() 类似，它也支持一系列参数来定制请求。以下是一些常见的 requests.post() 的参数及其说明：\n\nurl (必需参数):\n用于指定请求的目标 URL。\n\n\n\nimport requests url = \"https://www.example.com\"response = requests.post(url)\n\ndata:\n用于传递请求体中的数据，通常用于表单提交。\n\n\n\npayload = {'key1': 'value1', 'key2': 'value2'}response = requests.post(url, data=payload)\n\njson:\n用于传递 JSON 数据，自动设置请求头的 Content-Type 为 application/json。\n\n\n\nimport json data = {'key1': 'value1', 'key2': 'value2'}response = requests.post(url, json=data)\n\nheaders:\n用于设置 HTTP 请求头，其中包含关于请求的信息，如用户代理、接受类型等。\n\n\n\nheaders = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}response = requests.post(url, headers=headers)\n\ncookies:\n用于传递 cookie。\n\n\n\ncookies = {'cookie_name': 'cookie_value'}response = requests.post(url, cookies=cookies)\n\nauth:\n用于设置 HTTP 认证信息，可以是元组 (username, password)。\n\n\n\nauth = ('username', 'password')response = requests.post(url, auth=auth)\n\ntimeout:\n设置请求超时时间，以秒为单位。\n\n\n\nresponse = requests.post(url, timeout=5)\n\nallow_redirects:\n指定是否允许重定向，默认为 True。\n\n\n\nresponse = requests.post(url, allow_redirects=False)\n\nfiles:\n用于上传文件，可以是一个包含文件名和文件内容的字典。\n\n\n\nfiles = {'file': ('filename.txt', open('filename.txt', 'rb'))}response = requests.post(url, files=files)\n\nproxies:\n用于设置代理。\n\n\n\nproxies = {'http': 'http://proxy.example.com', 'https': 'https://proxy.example.com'}response = requests.post(url, proxies=proxies)\n\nstream:\n如果设置为 True，则会立即下载响应内容的一部分，并且可以通过迭代器逐步获取剩余的内容。\n\n\n\nresponse = requests.post(url, stream=True)for chunk in response.iter_content(chunk_size=128):    print(chunk)\n\nverify:\n用于控制是否进行 SSL 证书验证。默认为 True，可以设置为 False 关闭验证，或者指定一个证书路径。\n\n\n\nresponse = requests.post(url, verify='/path/to/certfile.pem')\n\ncert:\n用于指定客户端证书文件路径，通常是一个包含证书和私钥的元组。\n\n\n\nresponse = requests.post(url, cert=('/path/to/client.cert', '/path/to/client.key'))\n\nparams和headers中的特殊字符处理:\n如果 URL 中包含特殊字符，可以使用 quote 函数进行编码。\n\n\n\nfrom urllib.parse import quote url = \"https://www.example.com/search\"search_query = \"hello world\"url_with_query = url + \"?q=\" + quote(search_query)response = requests.post(url_with_query)\n这些是一些常见和不太常见但有用的参数。在实际使用中，根据具体的需求，可以查阅 requests 官方文档 获取更多详细信息。\n响应信息\n\n\n属性/方法\n描述\n\n\n\napparent_encoding\n编码方式\n\n\nclose()\n关闭与服务器的连接\n\n\ncontent\n返回响应的内容，以字节为单位\n\n\ncookies\n返回一个 CookieJar 对象，包含了从服务器发回的 cookie\n\n\nelapsed\n返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。\n\n\nencoding\n解码 r.text 的编码方式\n\n\nheaders\n返回响应头，字典格式\n\n\nhistory\n返回包含请求历史的响应对象列表（url）\n\n\nis_permanent_redirect\n如果响应是永久重定向的 url，则返回 True，否则返回 False\n\n\nis_redirect\n如果响应被重定向，则返回 True，否则返回 False\n\n\niter_content()\n迭代响应\n\n\niter_lines()\n迭代响应的行\n\n\njson()\n返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误)\n\n\nlinks\n返回响应的解析头链接\n\n\nnext\n返回重定向链中下一个请求的 PreparedRequest 对象\n\n\nok\n检查 “status_code” 的值，如果小于400，则返回 True，如果不小于 400，则返回 False\n\n\nraise_for_status()\n如果发生错误，方法返回一个 HTTPError 对象\n\n\nreason\n响应状态的描述，比如 “Not Found” 或 “OK”\n\n\nrequest\n返回请求此响应的请求对象\n\n\nstatus_code\n返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found）\n\n\ntext\n返回响应的内容，unicode 类型数据\n\n\nurl\n返回响应的 URL\n\n\n响应，由服务端返回给客户端，可以分为三部分：响应状态码（Response Status Code）、响应头 （Response Headers）和响应体（Response Body）。\n\n响应状态码\n响应状态码表示服务器的响应状态，如 200 代表服务器正常响应，404 代表页面未找到，500 代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为 200，则证明成功返回数据，再进行进一步的处理，否则直接忽略。\n\n常见的状态码及其原因\n\n\n\n状态码\n说 明\n详 情\n\n\n\n100\n继续\n请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分\n\n\n101\n切换协议\n请求者已要求服务器切换协议，服务器已确认并准备切换\n\n\n200\n成功\n服务器已成功处理了请求\n\n\n201\n已创建\n请求成功并且服务器创建了新的资源\n\n\n202\n已接受\n服务器已接受请求，但尚未处理\n\n\n203\n非授权信息\n服务器已成功处理了请求，但返回的信息可能来自另一个源\n\n\n204\n无内容\n服务器成功处理了请求，但没有返回任何内容\n\n\n205\n重置内容\n服务器成功处理了请求，内容被重置\n\n\n206\n部分内容\n服务器成功处理了部分请求\n\n\n300\n多种选择\n针对请求，服务器可执行多种操作\n\n\n301\n永久移动\n请求的网页已永久移动到新位置，即永久重定向\n\n\n302\n临时移动\n请求的网页暂时跳转到其他页面，即暂时重定向\n\n\n303\n查看其他位置\n如果原来的请求是 POST，重定向目标文档应该通过 GET 提取\n\n\n304\n未修改\n此次请求返回的网页未修改，继续使用上次的资源\n\n\n305\n使用代理\n请求者应该使用代理访问该网页\n\n\n307\n临时重定向\n请求的资源临时从其他位置响应\n\n\n400\n错误请求\n服务器无法解析该请求\n\n\n401\n未授权\n请求没有进行身份验证或验证未通过\n\n\n403\n禁止访问\n服务器拒绝此请求\n\n\n404\n未找到\n服务器找不到请求的网页\n\n\n405\n方法禁用\n服务器禁用了请求中指定的方法\n\n\n406\n不接受\n无法使用请求的内容响应请求的网页\n\n\n407\n需要代理授权\n请求者需要使用代理授权\n\n\n408\n请求超时\n服务器请求超时\n\n\n409\n冲突\n服务器在完成请求时发生冲突\n\n\n410\n已删除\n请求的资源已永久删除\n\n\n411\n需要有效长度\n服务器不接受不含有效内容长度标头字段的请求\n\n\n412\n未满足前提条件\n服务器未满足请求者在请求中设置的其中一个前提条件\n\n\n413\n请求实体过大\n请求实体过大，超出服务器的处理能力\n\n\n414\n请求 URI 过长\n请求网址过长，服务器无法处理\n\n\n415\n不支持类型\n请求格式不被请求页面支持\n\n\n416\n请求范围不符\n页面无法提供请求的范围\n\n\n417\n未满足期望值\n服务器未满足期望请求标头字段的要求\n\n\n500\n服务器内部错误\n服务器遇到错误，无法完成请求\n\n\n501\n未实现\n服务器不具备完成请求的功能\n\n\n502\n错误网关\n服务器作为网关或代理，从上游服务器收到无效响应\n\n\n503\n服务不可用\n服务器目前无法使用\n\n\n504\n网关超时\n服务器作为网关或代理，但是没有及时从上游服务器收到请求\n\n\n505\nHTTP 版本不支持\n服务器不支持请求中所用的 HTTP 协议版本\n\n\n\n响应头\n响应头包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。下面简要说明一\n些常用的头信息。\n\nDate：标识响应产生的时间。\nLast-Modified：指定资源的最后修改时间。\nContent-Encoding：指定响应内容的编码。\nServer：包含服务器的信息，比如名称、版本号等。\nContent-Type：文档类型，指定返回的数据类型是什么，如 text/html 代表返回 HTML 文档，\napplication/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则代表返回图片。\nSet-Cookie：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。\nExpires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。\n\n​\n\n响应体\n最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的 HTML 代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体\n\n​\n\n在浏览器开发者工具中点击 预览，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、JSON 数据等，然后从中做相应内容的提取。\n​\n\n\n","categories":["Python"],"tags":["requests"]},{"title":"Trap","url":"/2023/12/30/Trap/","content":"记录一些补充知识\n函数函数的参数默认参数:\n必选参数在前， 默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面） -&gt; 照应结尾 结尾也有这个问题\n函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n调用的时候, 可以按顺序提供默认参数, 当不按顺序提供部分默认参数时, 需要把参数名写上\n\n坑\ndef add_end(L=[]):    L.append('END')    return L add_end([1, 2, 3])# print[1, 2, 3, 'END'] add_end()# print['END'] # 前面都正常， 再次调用发现不对add_end()# print['END', 'END'] \n原因解释\n\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n\n定义默认参数要牢记一点：默认参数必须指向不变对象！  eg: str、None 类型\n可变位置参数（*args）def func(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum\n\n在函数定义中，*numbers 使用了星号 * 表示参数 numbers 是一个可变位置参数，它允许接受 任意数量（0个或任意个） 的位置参数，并将它们封装成一个 元组具体来说，在你的函数定义中，*numbers 接受任意数量的参数，将它们作为一个元组传递给 numbers。在函数体内，你可以通过迭代 numbers 来访问传递的所有参数。\n\n如果你已经有一个包含参数的列表或元组，并希望将它们作为可变参数传递给一个函数，你可以使用 * 操作符进行拆包。\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\nnums = [1, 2, 3]&gt;&gt;&gt; func(nums[0], nums[1], nums[2])14\n这样写显然是太费劲了 所以可以用下面操作\n在调用函数时，可以使用 * 操作符将列表或元组中的元素解包，并传递给可变参数。下面是一个示例：\ndef calc(*numbers):    total = sum(n * n for n in numbers)    return total # 通过列表调用可变参数函数numbers_list = [1, 2, 3]result_list = calc(*numbers_list)print(result_list) # 通过元组调用可变参数函数numbers_tuple = (4, 5, 6)result_tuple = calc(*numbers_tuple)print(result_tuple)\n在这个例子中，calc(*numbers_list) 将列表中的元素解包，相当于调用 calc(1, 2, 3)。同样，calc(*numbers_tuple) 将元组中的元素解包，相当于调用 calc(4, 5, 6)。\n使用 * 操作符可以方便地将列表或元组中的元素传递给可变参数，而无需手动指定每个参数。\n关键词参数也是同样道理， 加俩*即可\n可变关键字参数（**kwargs）跟可变参数差不多啦，关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict.\n关键字参数是在函数调用时通过指定参数名来传递值的一种方式。在函数定义中，可以使用 **kwargs（或其他名称，通常约定俗成使用 **kwargs）来接收关键字参数。在函数体内，kwargs 将是一个包含传递的关键字参数的字典。\n下面是一个简单的示例，演示如何使用关键字参数：\ndef print_info(name, age, **kwargs):    print(f\"Name: {name}\")    print(f\"Age: {age}\")     # 打印关键字参数    for key, value in kwargs.items():        print(f\"{key}: {value}\") # 使用关键字参数调用函数print_info(name=\"John\", age=30, city=\"New York\", occupation=\"Engineer\")\n在这个例子中，print_info 函数有两个普通参数 name 和 age，以及一个可变的关键字参数 **kwargs。通过在函数调用时使用关键字参数，我们可以传递额外的键值对作为关键字参数。\n调用 print_info(name=\"John\", age=30, city=\"New York\", occupation=\"Engineer\") 将输出：\nName: JohnAge: 30city: New Yorkoccupation: Engineer\n请注意，在函数体内，**kwargs 被视为一个字典，可以通过迭代它的键值对来访问关键字参数的信息。这样的设计允许函数接受任意数量的关键字参数。\n同样的你已经有一个dict了怎么调用关键字参数呢 如下：\n如果已经有一个字典，你可以使用解包操作符 ** 来将字典中的键值对作为关键字参数传递给函数。这种方式允许你使用字典的内容调用带有关键字参数的函数。\n以下是一个示例：\ndef print_info(name, age):    print(f\"Name: {name}\")    print(f\"Age: {age}\") # 已经有一个字典info_dict = {\"name\": \"John\", \"age\": 30} # 使用解包操作符 ** 将字典作为关键字参数传递给函数print_info(**info_dict)\n在这个例子中，**info_dict 将字典 info_dict 中的键值对解包为关键字参数，并传递给 print_info 函数。这样，就可以使用字典中的内容调用带有关键字参数的函数。\n请注意，字典中的键必须与函数定义中的参数名相匹配，否则会引发 TypeError。此外，使用解包操作符时，确保字典中的每个键都有对应的值。\n错误示范:\n如果字典中有多余的键值对，而函数的参数中没有对应的参数名，那么这些多余的键值对将被忽略，不会引发错误。这是因为解包操作符 ** 只会将字典中与函数参数名匹配的键值对传递给函数。\n以下是一个示例，演示了字典中有多余键值对时的情况：\ndef print_info(name, age, **kwargs):    print(f\"Name: {name}\")    print(f\"Age: {age}\") # 已经有一个字典，包含多余的键值对info_dict = {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"} # 使用解包操作符 ** 将字典作为关键字参数传递给函数# 多余的键值对 \"city\": \"New York\" 会被忽略print_info(**info_dict) # printName: JohnAge: 30\n在这个例子中，info_dict 包含多余的键值对 “city”: “New York”，但由于函数 print_info 只接受 name 和 age 两个参数，多余的键值对会被忽略。函数调用不会引发错误，且只会使用匹配的参数进行打印。这种方式使得你可以在字典中包含多余的信息，而无需担心会破坏函数调用。只有与函数参数名匹配的键值对会被传递给函数。\n命名关键字参数要限制关键字参数的名字，就可以用命名关键字参数\n在 Python 中，命名关键字参数是一种函数参数的类型，它允许你明确指定某些关键字参数必须使用关键字传递，而不能作为位置参数传递。这样可以提高函数调用的可读性和可维护性。\n在函数定义中，通过在参数列表中 使用单个星号 *（用于表示位置参数的结束）后面的参数来声明命名关键字参数 。这些参数需要在函数调用时明确使用关键字传递。\n以下是一个简单的示例：\ndef greet(name, age, *, city, occupation):    print(f\"Name: {name}\")    print(f\"Age: {age}\")    print(f\"City: {city}\")    print(f\"Occupation: {occupation}\") # 使用命名关键字参数调用函数greet(\"John\", 30, city=\"New York\", occupation=\"Engineer\")\n在这个例子中，city 和 occupation 被声明为命名关键字参数，因为它们出现在 * 后面。当调用 greet 函数时，__必须使用关键字来指定这两个参数的值__。\n注意，如果你尝试使用位置参数传递命名关键字参数，将会引发 TypeError。\n# 以下调用将引发 TypeError# greet(\"John\", 30, \"New York\", \"Engineer\")\n命名关键字参数的使用可以帮助防止在函数调用时出现歧义，特别是在函数具有大量参数时。这样的做法使得函数接口更加清晰，并提高了代码的可读性。\n如果函数定义中已经有了一个可变参数（例如，带有 *args），你可以在其后声明命名关键字参数。可变参数之后的参数都需要使用关键字传递。\n以下是一个示例：\ndef process_data(name, age, *args, city=\"New York\", occupation):    print(f\"name: {name}\")    print(f\"age: {age}\")    print(\"Positional arguments:\", args)    print(f\"City: {city}\")    print(f\"Occupation: {occupation}\") # 使用可变参数和命名关键字参数调用函数process_data('wxylkayz', 21, 1,2, 3, occupation=\"Engineer\")\n在这个例子中，*args 表示可变位置参数，可以接受任意数量的位置参数。而 city 和 occupation 则是命名关键字参数，需要使用关键字传递。 ps:此处city指定了默认参数可以不写\n简而言之: 如果不用关键字传递参数，Python解释器把前两个参数视为位置参数，后两个参数传给*args，因为缺少命名关键字参数导致报错。\n注意，在调用函数时，如果你使用了可变参数，必须确保在关键字参数之前传递所有的位置参数 ，否则将引发 SyntaxError。\n# 以下调用将引发 SyntaxError# process_data(city=\"New York\", occupation=\"Engineer\", 1, 2, 3)\n总的来说，如果函数定义中已经有了一个可变参数，你可以在其后声明命名关键字参数，并在函数调用时使用关键字传递。\n参数组合摘选自 廖雪峰Python在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。\n但是请注意，参数定义的 顺序 必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\ndef f1(a, b, c=0, *args, **kw):    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw) def f2(a, b, c=0, *, d, **kw):    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) &gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = {} &gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {} &gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = {} &gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99} &gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'} &gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\nps: 想一下以下可否成功调用\nargs = (1, 2, 3)kw = {'z': 88, 'x': '#'}f2(*args, **kw)\n\n我的理解就是解包后看作顺序填充所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。ps: 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。\n\n闭包闭包（Closure）是一种函数对象，它包含了函数定义体中引用、但是不在定义体中定义的非全局变量。换句话说，闭包允许函数引用在其外部定义的非全局变量。\n在理解闭包之前，我们先来看一个简单的例子：\ndef outer_function(x):    def inner_function(y):        return x + y    return inner_function closure = outer_function(10)result = closure(5)print(result)  # 输出 15\n在这个例子中，outer_function 返回了 inner_function，并且 inner_function 中引用了 outer_function 中的变量 x。当我们调用 outer_function(10) 时，它返回了 inner_function，这个返回的函数就是一个闭包。之后，我们可以使用 closure(5) 来调用闭包，它会使用 x=10 的值，最终返回 15。\n闭包有几个重要的特点：\n\n引用外部变量： 闭包允许函数访问在其外部定义的非全局变量。在上面的例子中，inner_function 访问了 outer_function 中的变量 x。\n\n保持状态： 闭包能够保持其作用域中的状态。在示例中，每次调用 closure(5) 时，它都记住了 x 的值为 10。\n\n延迟执行： 通过闭包，我们可以将函数的执行延迟到以后的时间。在上述例子中，我们并没有立即执行 inner_function，而是将它赋给了 closure，稍后再调用。\n\n\n使用闭包可以有效地隐藏函数的一些实现细节，同时允许在不同的调用之间保持状态。这在某些编程场景中非常有用。\n","categories":["Python"],"tags":["Python"]},{"title":"Vps搭建系列","url":"/2023/04/13/Vps%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97/","content":"总有一些时候，你想要一台自己的 VPS 。\n \n\n网络通信基本过程略\nGFW防火墙GFW防火墙是怎么阻断我们和谷歌的连接？如何绕过防火墙的拦截？DNS污染是怎么回事？搭建节点之前必须知道的知识\nDNS污染(DNS劫持)这里假设GFW没有拦截你的DNS请求\n\n访问google\n查找本地host缓存\n找到: 向直接构造请求(先假设找不到)\n没找到: 向dns服务器发送请求(假设GFW没有拦截你的dns请求) -&gt; 跳跳跳跳到DNS服务器返回给你google的ip地址 -&gt; 返回数据 -&gt; 走到GFW解析到你的应用层意图 想访问google 修改你的数据 -&gt; 返回给你一个假的ip -&gt; pass\n\n\n\nTCP重置攻击假设你直接在host中设置了 google的ip跟域名的映射 不需要在进行上面的dns请求goole可以有多个服务器也就是多个ip地址\n\n访问google\n查找本地host缓存\n找到\n访问google -&gt; 建立tcp连接\nGFW只要解析到网络层就可以看到你请求的ip地址, 如果在黑名单里这个ip地址 -&gt; 直接pass掉你这数据包/伪装成谷歌的服务器 给你返回错误的数据 —&gt; tcp连接失败\n如果不在黑名单 -&gt; 成功建立tcp连接 -&gt; 开始给google的ip请求首页数据 -&gt; GFW解析到你的应用层数据，请求google.com的首页数据, google.com域名在黑名单 -&gt; 直接pass掉这个数据包\n\n\n\n\n\n\n\n","categories":["随笔"],"tags":["VPS"]},{"title":"Xpath","url":"/2023/12/30/Xpath/","content":"Xpath学习\n本片完全基于菜鸟教程学习\n术语&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;bookstore&gt;  &lt;book&gt;    &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt;    &lt;author&gt;J K. Rowling&lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;29.99&lt;/price&gt;  &lt;/book&gt;&lt;/bookstore&gt;\n下面以此xml文档为练习\n\n节点在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。\n\n文档节点/根节点 : &lt;bookstore&gt;\n属性节点 : lang=\"en\"\n元素节点 : 例如 &lt;year&gt;2005&lt;/year&gt;\n\n\n基本值(原子值)基本值是无父或无子的节点\n\neg : J K. Rowling、\"en\"\n\n\n项目（Item）项目是基本值或者节点\n\n节点关系\n\n父\n子\n同胞\n先辈 (从父往上)\n后代 (从子往下)\n\n\n\n语法&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  &lt;bookstore&gt;  &lt;book&gt;  &lt;title lang=\"eng\"&gt;Harry Potter&lt;/title&gt;  &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;  &lt;book&gt;  &lt;title lang=\"eng\"&gt;Learning XML&lt;/title&gt;  &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;  &lt;/bookstore&gt;\n下面以此xml文档为练习\n选取节点\n\n\n表达式\n描述\n\n\n\nnodename\n选取此节点的所有子节点\n\n\n/\n从根节点起选取\n\n\n//\n从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）\n\n\n.\n选取当前节点\n\n\n..\n选取当前节点的父节点\n\n\n@\n选取属性\n\n\n举例: \n\n\n\nxpath表达式\n结果\n\n\n\nbookstore\n选取bookstore的所有子节点\n\n\n/bookstore\n以bookstore作根节点 (注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！)\n\n\nbookstore/book\n选取属于 bookstore 的子元素的所有 book 元素\n\n\n//book\n选取所有 book 子元素，而不管它们在文档中的位置\n\n\nbookstore//book\n选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。\n\n\n谓语谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。\n\n\n\n表达式\n结果\n\n\n\n/bookstore/book[1]\n/bookstore下第一个book节点\n\n\n/bookstore/book[last()]\n/bookstore下最后一个book节点\n\n\n/bookstore/book[last()-1]\n/bookstore下倒数第二个book节点\n\n\n/bookstore/book[position()&lt;3]\n选取最前面的两个属于/bookstore的子元素的book元素\n\n\n//title[@lang]\n所有具有lang属性的title\n\n\n//title[@lang=’eng’]\n所有带lang属性且属性值为eng的title\n\n\n/bookstore/book[price&gt;35]\n/bookstore的所有price元素&gt;35的book元素\n\n\n/bookstore/book[price&gt;35]/title\n所有/bookstore下price&gt;35的book元素的子元素title\n\n\n通配符* : 匹配任意节点@*: 匹配任意属性节点node(): 匹配任意类型的节点\n选取若干路径|运算符\n\n\n\n路径表达式\n结果\n\n\n\n//book/title | //book/price\n选取 book 元素的所有 title 和 price 元素。\n\n\n轴\n\n\n轴名称\n结果\n\n\n\nancestor\n选取当前节点的所有先辈（父、祖父等）。\n\n\nancestor-or-self\n选取当前节点的所有先辈（父、祖父等）以及当前节点本身。\n\n\nattribute\n选取当前节点的所有属性。\n\n\nchild\n选取当前节点的所有子元素。\n\n\ndescendant\n选取当前节点的所有后代元素（子、孙等）。\n\n\ndescendant-or-self\n选取当前节点的所有后代元素（子、孙等）以及当前节点本身。\n\n\nfollowing\n选取文档中当前节点的结束标签之后的所有节点。\n\n\nfollowing-sibling\n选取当前节点之后的所有兄弟节点。\n\n\nnamespace\n选取当前节点的所有命名空间节点。\n\n\nparent\n选取当前节点的父节点。\n\n\npreceding\n选取文档中当前节点的开始标签之前的所有节点。\n\n\npreceding-sibling\n选取当前节点之前的所有同级节点。\n\n\nself\n选取当前节点。\n\n\n","categories":["Python"],"tags":["Xpath"]},{"title":"常用Git命令清单","url":"/2022/05/18/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/","content":"我每天使用 Git, 但是很多命令记不住. 一般来说, 日常使用只要记住下图6个命令, 就可以了. 但是熟练使用, 恐怕要记住60～100个命令.\n \n下面是我整理的常用Git命令清单. 几个专用名词的译名如下.  \n\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n详细教程参考: Git 教程 缪雪峰转载: 常用 Git 命令清单  阮一峰\n新建代码库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n配置Git 的设置文件为 .gitconfig, 它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)\n# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\"\n\n添加/删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n\n对于文件删除操作使用git restore --staged &lt;deleted file&gt;(撤销删除操作)丢弃暂存区该次删除操作, 在git checkout -- &lt;delete file&gt; (丢弃删除操作)\ntest.txt（2行文字） ——add——commit——rm——checkout——这样删除了你会获得test.txt（2行文字）\ntest.txt （2行文字）——add——commit——修改增加test.txt的内容（3行文字）——rm——checkout——这样删除了你会获得test.txt（2行文字）\nPS:只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容\n说白了就是最后一次提交以后，你做出的修改因为没有提交到版本库，所以删除文件再从版本库中进行恢复，恢复的是提交的最新版本，这里面并不包括你刚刚做出的修改。\n代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n\n分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git switch -c &lt;name&gt;# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git switch &lt;name&gt;# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]\n\n查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog\n\n远程同步关联要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。git clone git@github.com:michaelliao/gitskills.git\nPS: Git支持多种协议，包括https，但ssh协议速度最快。\n# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n\n撤销/时光回溯场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git restore &lt;file&gt;\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git restore --staged &lt;file&gt;，就回到了场景1，第二步按场景1操作(这里也就解释了是撤销的add这个操作 工作区没变 所以需要再次使用第一步)。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，git reset –hard commit_id。结果：工作区文件、暂存区文件、本地仓库都回退，不过前提是没有推送到远程库。\nHEAD指向的版本是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。(HEAD^ HEAD^^……..HEAD~100 : 利用数字回退版本 上面是利用commit_id)\n穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 (此时在commit时携带的m就有用了 知道干了什么才能准确回退)\n要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n# 恢复暂存区的指定文件到工作区   白话文: 把workspace的修改全部撤销(是把未add之前在workspace的修改全部撤销)$ git restore &lt;file&gt; # 把暂存区的修改回退到工作区(这里的修改是指add这个操作！！！ 撤销的是操作一定记住！ 并不是文档内的内容 , git add git rm 这些添加删除都叫修改！)$ git restore --staged &lt;file&gt;  # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n\n其他# 生成一个可供发布的压缩包$ git archive\n\n待续……当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n用git log --graph命令可以看到分支合并图。用带参数的git log也可以看到分支的合并情况：\ngit log --graph --pretty=oneline --abbrev-commit\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n使用Fast forward模式，指针直接指向dev禁用Fast forward模式，指针向后平移一个新的commit\n开发一个新feature，最好新建一个分支；\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。\n","categories":["随笔"],"tags":["Git"]},{"title":"问题小记","url":"/2023/01/18/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/","content":"开此篇用于记录平时的一些小技巧小错误\n \n\n\nLinux系列个性化PS1=\"\\[\\033[1;35m\\][\\u@\\h \\W]\\$\\[\\033[1;34m\\]\"export PS1\nvim安装vim编辑器需要安装三个包：\nvim-X11-7.4.629-6.el7.x86_64vim-common-7.4.629-6.el7.x86_64vim-enhanced-7.4.629-6.el7.x86_64vim-minimal-7.4.629-6.el7.x86_64vim-filesystem-7.4.629-6.el7.x86_64\n\n查看一下你本机已经存在的包，确认一下你的VIM是否已经安装：输入 rpm -qa|grep vim，如果vim已经正确安装，则会显示上面四个包的名称\n如果缺少了其中某个，比如说：vim-enhanced这个包少了，执行：yum -y install vim-enhanced\n如果上面包一个都没有显示，则直接输入命令：yum -y install vim*即可\n\nDocker系列Docker安装curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun\n自启动systemctl enable docker\nDocker使用代理在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置.  \nmkdir -p /etc/systemd/system/docker.service.dvim /etc/systemd/system/docker.service.d/proxy.conf\n在这个proxy.conf文件（可以是任意*.conf的形式）中，添加以下内容：\n[Service]Environment=\"HTTP_PROXY=http://proxy.example.com:8080/\"Environment=\"HTTPS_PROXY=http://proxy.example.com:8080/\"Environment=\"NO_PROXY=localhost,127.0.0.1,.example.com\"\n\n其中，proxy.example.com:8080要换成可用的免密代理。  \n重启生效代理配置完成后，reboot 重启当然可以生效，但不重启也行.  \ndocker build代理是在执行前设置的，所以修改后，下次执行立即生效。Container代理的修改也是立即生效的，但是只针对以后启动的Container，对 已经启动 的Container无效。\ndocker代理的修改比较特殊，它实际上是改systemd的配置，因此需要重载systemd并重启docker才能生效。  \nsystemctl daemon-reloadsystemctl restart docker\n代理系列linux使用代理一般情况下  \n# 只作用于当前终端中, 不影响环境# http/httpsexport http_proxy=\"http://user:pwd@ip:port\"export https_proxy=\"http://user:pwd@ip:port\"# socks5export http_proxy=\"socks5://user:pwd@ip:port\"export https_proxy=\"socks5://user:pwd@ip:port\"# all_proxyexport ALL_PROXY=\"socks5://user:pwd@ip:port\"# 永久生效  把代理写入shell配置文件.bashrc或者.zshrc然后source即可#PS： 使用sudo时注意：通sudo常用来以超级用户（root）的权限执行命令。默认情况下，sudo 会使用一个较为干净的环境，只有一小部分安全相关的环境变量会被保留，其余的用户环境变量（如 PATH、HTTP_PROXY 等）不会被继承      sudo -E ： 执行命令时保留调用用户的环境变量\n特殊情况\n有的应用即使设置了代理也不会走代理 需要用到proxychains4 下面介绍\nlinux命令行代理神器-proxychains-ng\nProxyChains是Linux和其他Unix下的代理工具。 它可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道， 支持HTTP、 SOCKS4和SOCKS5类型的代理服务器， 并且可配置多个代理。 ProxyChains通过一个用户定义的代理列表强制连接指定的应用程序， 直接断开接收方和发送方的连接。ProxyChains 是一个强制应用的 TCP 连接通过代理的工具，支持 Tor、HTTP、与 Socks 代理。与 sshuttle 不同的是，ProxyChains 只会将当前应用的 TCP 连接转发至代理，而非全局代理。\n\n官方文档 Wiki  \n安装\n# 需要一个可用的 C 编译器，最好是 gcc./configure --prefix=/usr --sysconfdir=/etcmake[可选] sudo make install[可选] sudo make install-config（安装 proxychains.conf）如果你不安装，你可以使用构建目录中的代理链像这样：./proxychains4 -f src/proxychains.conf telnet google.com 80\nUbuntu、Deepin 直接apt install proxychains4即可  \n配置\n安装完毕之后需要设置代理配置:ProxyChains 的配置文件位于 /etc/proxychains4.conf ，打开后你需要在末尾添加你使用的代理。\n[ProxyList]# add proxy here ...# meanwile# defaults set to \"tor\"#socks4    127.0.0.1 9050# examplesocks5  127.0.0.1 7890\n\neg  \nproxychains4 curl myip.ipip.net--------[proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/aarch64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:7890  ...  127.0.0.1:7890  ...  myip.ipip.net:80  ...  OK当前 IP：95.174.71.19  来自于：美国 加利福尼亚州 洛杉矶  edis.at\n\n测试带宽speedtest比较简单  安装使用即可\n\n安装apt install speedtest-cli\n使用speedtest\n测试科学上网速度proxychains4 speedtest\n\niperf测试内网路由器的速度的极限\niperf 官网\n代挂系列懒得折腾可以私我上车 q2501375882 Telegram\nqinglong安装安装Dockerhub\ndocker run -dit \\  -v $PWD/ql:/ql/data \\  -p 5700:5700 \\  --name qinglong \\  --hostname qinglong \\  --restart unless-stopped \\  whyour/qinglong:latest\n第一个5700端口是指本机端口可以修改，第二个不可修改。\n依赖nodejs依赖\n\npng-jsdate-fnsaxiosdotenvgotcrypto-jsmd5ts-md5tslib@types/noderequeststough-cookiejsdomdownloadtunnelwsjs-base64qrcode-terminalmomentform-datafsdssilly-datetime\n\npython依赖\n\nPyExecJSbs4redisrequestsTomlipython-dotenv\n\n安装python依赖一直失败解决方法： \n容器内执行以下命令后重新安装curl -sS https://bootstrap.pypa.io/get-pip.py | python3如果没反应就多等一会, 或者设置系统代理，再或者下载下py到本地上传到容器中 设置代理执行这个脚本\n安装nodejs依赖一直失败解决方法：两种方法\n\n容器内给npm设置代理\n更换淘宝源\n\n使用以下命令来为Node设置代理：\nnpm config set proxy http://proxy.server.com:portnpm config set https-proxy http://proxy.server.com:port\n\n将http://proxy.server.com:port替换为您实际的代理服务器地址和端口号。\n如果您需要身份验证才能连接代理服务器，可以使用以下命令设置用户名和密码：\nnpm config set proxy http://username:password@proxy.server.com:portnpm config set https-proxy http://username:password@proxy.server.com:port\n\n查看Node使用的代理：\nnpm config get proxynpm config get https-proxy\n\n如果这些命令返回空，那么Node没有配置任何代理。如果代理已配置，则命令将返回代理的URL。\nPro安装\n先执行 mkdir /root/pro &amp;&amp; cd /root/pro   \n创建容器docker run -id \\--name pro -p 5701:5016 \\-v \"$(pwd)\":/app/Data \\-e Prolic=授权码 \\-e User=用户名 \\-e Pwd=密码 \\--restart unless-stopped \\--privileged=true \\nolanhzy/pro:latest\n授权许可自行解决\n\n更新:docker run --rm     -v /var/run/docker.sock:/var/run/docker.sock     containrrr/watchtower -c     --run-once     pro\n科学上网系列Clash安装使用mkdir Clash &amp;&amp; cd Clash &amp;&amp; mkdir UIdocker run -d --name Clash --restart always \\  -p 7890:7890 -p 9090:9090 \\  -v \"/root/Clash/config.yaml:/root/.config/clash/config.yaml\" \\  -v \"/root/Clash/UI:/root/.config/clash/ui\" \\  dreamacro/clash\n创建Clash文件夹后需要放入配置文件可以使用clash作者自带的面板 看个人, 我使用的是yacd的面板下载后解压放入UI,然后docker restart Clash即可clash端口相关配置  \n# Port of HTTP(S) proxy server on the local endport: 7890# Port of SOCKS5 proxy server on the local endsocks-port: 7891# Transparent proxy server port for Linux and macOS (Redirect TCP and TProxy UDP)redir-port: 7892# Transparent proxy server port for Linux (TProxy TCP and TProxy UDP)# tproxy-port: 7893# HTTP(S) and SOCKS5 server on the same port，混合端口mixed-port: 7893\n挂载硬盘dev目录\n/dev 是 Linux 系统中的一个特殊目录，用于存储设备文件。在 Linux 中，一切设备都被视为文件，包括硬盘、分区、磁盘、终端、打印机、输入设备等等。这些设备文件位于 /dev 目录下，以方便系统和应用程序与设备进行交互。\n\n当你插入一个新的硬件设备（如硬盘、USB 设备、光驱等）时，系统会自动在 /dev 目录下创建相应的设备文件，以便系统能够识别和使用这些设备。这些设备文件通常以 sd 或 hd 开头，后面跟上字母和数字的组合，用来标识不同的设备和分区。\n例如：\n\n/dev/sda 表示第一个 SATA 硬盘设备。\n/dev/sdb 表示第二个 SATA 硬盘设备。\n/dev/sda1 表示第一个 SATA 硬盘设备的第一个分区。\n/dev/sda2 表示第一个 SATA 硬盘设备的第二个分区。\n/dev/sdb1 表示第二个 SATA 硬盘设备的第一个分区。\n\n类似的，其他类型的设备也有相应的设备文件，例如：\n\n/dev/tty 表示终端设备。\n/dev/lp0 表示打印机设备。\n\n通过读写这些设备文件，应用程序和系统可以与硬件设备进行交互，读取和写入数据，实现硬件设备的控制和管理。\n总之，/dev 目录是 Linux 系统中用于存储设备文件的特殊目录，为系统提供了一种统一的方式来访问和管理各种硬件设备。\n挂载在 Linux 中挂载硬盘需要以下几个步骤：\n\n插入硬盘：如果你要挂载的是外部硬盘或 USB 存储设备，首先要将硬盘插入到计算机的 USB 接口或其他硬盘接口上。\n\n查看硬盘信息：插入硬盘后，使用以下命令查看硬盘的信息，包括硬盘设备名称和分区信息：\n\n\nsudo fdisk -l\n\n\n创建挂载点：在 Linux 中，你需要选择一个目录作为挂载点，这将成为你访问硬盘内容的入口。可以在 /mnt 或 /media 目录下创建一个新的子目录作为挂载点，例如：\n\nsudo mkdir /mnt/my_hard_drive\n\n\n挂载硬盘：使用 mount 命令将硬盘挂载到刚刚创建的挂载点上。假设硬盘设备名称是 /dev/sdb1，可以执行以下命令：\n\nsudo mount /dev/sdb1 /mnt/my_hard_drive\n\n请注意，如果硬盘已经被挂载到其他目录，或者正在使用中，将无法成功挂载到新的挂载点。在这种情况下，需要先卸载之前的挂载点，然后再进行挂载。\n\n验证挂载：使用以下命令可以验证硬盘是否成功挂载到指定的挂载点：\n\ndf -h\n\n这个命令会显示已挂载的文件系统列表，你应该能够在列表中看到刚刚挂载的硬盘。\n\n自动挂载：如果你希望系统在每次启动时自动挂载硬盘，可以将挂载信息添加到 /etc/fstab 文件中。编辑这个文件，添加类似以下的一行内容：\n\n/dev/sdb1  /mnt/my_hard_drive  ext4  defaults  0  0\n\n保存并退出 /etc/fstab 文件后，重启系统，硬盘应该会自动挂载到指定的挂载点。\n以上就是在 Linux 中挂载硬盘的基本步骤。请注意，在挂载和卸载硬盘时，务必小心操作，确保没有数据丢失或损坏。如果你对硬盘的分区和文件系统不熟悉，建议提前备份任何重要数据并谨慎操作。\n卸载在 Linux 中，要卸载（取消挂载）已经挂载的硬盘或分区，可以使用 umount 命令。请按照以下步骤进行：\n\n确定挂载点：首先，你需要知道硬盘或分区挂载的目录，也就是挂载点。你可以使用 mount 命令或 df 命令查看已挂载的文件系统和挂载点：\nmount\n\n或者\ndf -h\n\n上述命令会显示已挂载的文件系统列表，包括挂载点信息。\n\n卸载硬盘或分区：使用 umount 命令卸载硬盘或分区。假设你的硬盘挂载在 /mnt/my_hard_drive 目录下，可以执行以下命令：\nsudo umount /mnt/my_hard_drive\n\n注意，需要使用 sudo 或以 root 权限运行该命令，以确保具有卸载的权限。\n\n验证卸载：执行 mount 命令或 df 命令来验证硬盘是否成功卸载：\nmount\n\n或者\ndf -h\n\n如果硬盘已成功卸载，将不再显示在已挂载的文件系统列表中。\n\n\n请注意，在执行 umount 命令前，确保没有进程在使用挂载点下的文件，否则卸载会失败。如果系统提示挂载点正在被使用，你可以通过 lsof 命令来查看哪些进程正在使用该挂载点：\nsudo lsof /mnt/my_hard_drive\n\n然后可以选择关闭相关进程或等待它们完成后再尝试卸载。\n总结：卸载硬盘或分区使用 umount 命令，确保没有进程在使用挂载点，使用 mount 或 df 命令验证卸载结果。如果有进程在使用挂载点，需要先关闭相关进程或等待它们完成。\nlsblklsblk 是一个 Linux 命令，用于列出块设备信息，包括硬盘、分区和其他存储设备。它提供了一个简洁的方式来查看系统中所有块设备的层次结构和相关信息。\n使用 lsblk 命令可以查看以下信息：\n\nNAME：块设备的名称，例如 /dev/sda 表示第一个 SATA 硬盘设备。\n\nMAJ:MIN：设备的主设备号和次设备号，这些数字用于内核识别和管理设备。\n\nRM：设备的类型，RM = 0 表示是一个可移动设备，RM = 1 表示是一个固定设备。\n\nSIZE：设备的大小，显示设备的容量大小。\n\nRO：设备的只读状态，RO = 1 表示设备为只读状态，RO = 0 表示设备可读可写。\n\nMOUNTPOINT：设备的挂载点，如果设备已经挂载，将显示挂载点的路径；否则显示为空。\n\n\n以下是一个 lsblk 命令的示例输出：\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTsda      8:0    0  465.8G  0 disk├─sda1   8:1    0   100M  0 part /boot/efi├─sda2   8:2    0    16M  0 part├─sda3   8:3    0  48.8G  0 part /├─sda4   8:4    0   100G  0 part /home├─sda5   8:5    0  50.5G  0 part└─sda6   8:6    0  266.4G  0 part /mnt/datasdb      8:16   0  931.5G  0 disk└─sdb1   8:17   0  931.5G  0 part /mnt/backup\n\n在上述示例中，lsblk 命令列出了两个块设备：sda 和 sdb。其中，sda 是第一个 SATA 硬盘设备，sdb 是第二个 SATA 硬盘设备。sda 硬盘包含多个分区，每个分区都有一个唯一的名称，例如 sda1、sda2 等。每个分区都可以挂载到不同的挂载点，如 /boot/efi、/、/home 等。\n通过 lsblk 命令，你可以快速了解系统中的硬盘和分区情况，以及它们的挂载状态和容量大小等信息，有助于进行硬件设备的管理和配置。\nMarkdown系列基本使用菜鸟教程\n小问题\n代码块可以用```包裹，但是结尾的```不要加两空格用来换行,会乱,直接回车！\n\n\n![替代文字](图片地址 \"可选标题\")\n\n\n\n\n[]内文本只有在图片无法正常显示时候才会显示出来，正常情况下是看不到的。如果插入的图片较多，利用图片说明文字可以在图片显示出错时快速定位出问题的是哪张图片。 \n可选标题是在鼠标悬停在图片上时显示的文字\n\nWindows系列W10 LSTC 2021版本 安装应用商店管理员身份打开Powershell输入命令行wsreset -i 等待一分钟点击左下角win,应该显示新安装store\n待续….Python代码打包使用PyInstaller 库打包\ncd 目录pyinstaller --onefile --icon=your_icon.ico your_script.py\n\n\n执行完上述命令后, PyInstaller库会将你的 Python 代码、所依赖的库和资源文件打包成一个独立的可执行文件。打包生成的可执行文件将会出现在一个名为dist的子目录中。其中 your_icon.ico 是你希望添加到 exe 文件中的图标文件,在dist目录下你会发现一个名为 your_script.exe 的可执行文件，它就是你的Python代码的独立可执行文件。\n\n你可以使用以下方法来给打包的 exe 文件添加自己的图标并去除黑窗口。\n\n添加自己的图标\n添加自己的图标可以通过在 PyInstaller 打包命令中添加 --icon 选项来实现。例如：\npyinstaller --onefile --icon=your_icon.ico your_script.py\n\n其中 your_icon.ico 是你希望添加到 exe 文件中的图标文件。\n\n去除黑窗口\n在 Windows 平台下，Exe 文件一运行就会弹出一个命令行窗口，如果你不希望出现这个窗口，可以添加 -w 或 --windowed 参数，这将启用 pyinstaller 库的 GUI 窗口模式。例如：\npyinstaller --onefile --icon=your_icon.ico --windowed your_script.py\n\n注意：在使用了 -w 参数启用 GUI 模式后，你的 Python 代码必须是全局作用域下的窗口应用程序。如果你的代码没有窗口界面，那么这个选项对其没有影响。\n另外，你也可以尝试在你的代码中添加下面这行。它可以帮助 Python 隐藏命令行窗口。\nimport osos.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'\n\nPS: 这种方式可能会与您的代码中使用的库发生冲突，因此不是每个人都能成功。\n\n\n","categories":["随笔"],"tags":["问题"]}]